/// Reusable mixin for registering states, variants, contexts, browsers, responsive...
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variant' | 'context' | 'browser' | 'responsive'
/// @param { String } $identifier - selector extension
/// @param { String } $args... - extra arguments for input values for placeholder '?' or alias name when context-like modifier ('context' | 'browser' | 'responsive')
/// @throw SPOT CSS: register/invalid-selector-extension - the mixin register { modifier-name(identifier) } uses invalid selector extension 'identifier'. The extension can start only with one of these characters: '.', '#', '@', '[', ':' (or '?' or '{' when placeholder is used).
/// @throw SPOT CSS: register/no-component - the mixin register { modifier-name(identifier) } must be used inside a component selector.
/// @throw SPOT CSS: register/missing-values - the mixin register { modifier-name(identifier) } uses '?' as value placeholder but no values were provided.
/// @throw SPOT CSS: register/extra-values - the mixin register { modifier-name(identifier) } doesn't use '?' as value placeholder but extra values were provided.
/// @output Nothing.
@mixin _register-modifiers($modifier-name, $identifier, $args...) { 
    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "register/no-component - the mixin register { "+$modifier-name+"("+$identifier+") } must be used inside a component selector.";
    }

    // is context-like (context, browser or responsive) or vriation-like (state or variant)
    $is-context-like: str-index($modifier-name, '&');

    // for variant-like selector extensions only valid first chars are: . # [ : (or '?' or '{' when placeholder is used)
    @if not $is-context-like {
        $first-char: str-slice(str-trim-left($identifier), 1, 1);
        @if $first-char!='.' and $first-char!='#' and $first-char!='[' and $first-char!=':' and $first-char!='?' and $first-char!='{' and $first-char!='@' {
            @error $SPOT_ERROR_PREFIX + "register/invalid-selector-extension - the mixin register { "+$modifier-name+"("+$identifier+") } uses invalid selector extension '"+$identifier+"'. The extension can start only with one of these characters: '.', '#', '@', [', ':' (or '?' or '{' when placeholder is used).";
        }
    }

    // if selector contains '?' (e.g. '[type="?"]') character, $args must be provided as expected values
    // expample arguments: ('state', '[type="?"]', 'primary', 'secondary')
    @if str-index($identifier, '?') or _is_alias($identifier) {
        $len: length($args);
        @if $len==0 {
            @error $SPOT_ERROR_PREFIX + "register/missing-values - the mixin register { "+$modifier-name+"("+$identifier+") } uses '?' as value placeholder but no values were provided.";
        }
        @else {
            $alias: $identifier;
            $placeholder-start: str-index($identifier, '?') or str-index($identifier, '{');
            $placeholder-end: str-index($identifier, '?') or str-index($identifier, '}');
            // register modifier for each given value individualy
            @for $i from 1 through $len {                 
                $selector: str-slice($identifier, 1, $placeholder-start - 1) + nth($args, $i) + str-slice($identifier, $placeholder-end + 1 );
                @include _register-individual-modifier($modifier-name, $selector, $alias, $do-not-check-alias: $i!=1); // check alias only for first modifier
            }
        }
    }
    // if selector does not contains "?" or "{" character, $args must be not provided (as expected values)
    @else {
        // if extra values
        @if $args!=null and length($args)!=0 {
            @error $SPOT_ERROR_PREFIX + "register/extra-values - the mixin register { "+$modifier-name+"("+$identifier+") } doesn't use '?' as value placeholder but extra values were provided.";
        }
        @else {
            // register modifier
            @include _register-individual-modifier($modifier-name, $identifier, $args...);
        }
    }
}


/// Reusable mixin for registering state, variant, context, browser or responsive.
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variant' | 'context' | 'browser' | 'responsive'
/// @param { String } $identifier - selector extension
/// @param { String } $alias - alias name when context-like modifier ('context' | 'browser' | 'responsive')
/// @param { Bool } $do-not-check-alias - flag to skip duplicity check for aliases
/// @throw SPOT CSS: register/sub-component-context - it is not allowed to register modifier(identifier) for sub-component 'component'. Register this 'modifier' in top parent component.
/// @throw SPOT CSS: register/child-component-context - it is not allowed to register modifier(identifier) for child-component 'component'. Register this 'modifier' in top parent component.
/// @throw SPOT CSS: register/duplicate-modifier - trying to register already registered modifier 'identifier' for component 'component'.
/// @throw SPOT CSS: register/duplicate-modifier-with-alias - trying to register modifier 'identifier' but there is already registered modifier with same alias for component 'component'.
/// @throw SPOT CSS: register/duplicate-alias-with-modifier - trying to register alias 'alias' but there is already registered same modifier for component 'component'.
/// @throw SPOT CSS: register/duplicate-modifier-alias - trying to register already registered modifier alias 'alias' for component 'component'.
/// @output Nothing.
@mixin _register-individual-modifier($modifier-name, $identifier, $alias: '', $do-not-check-alias: false) {    
    // backup
    $original-identifier: $identifier;    
    
    $alias: _normalize-alias($alias);
    $identifier: _add-default-ampersand-if-context($modifier-name, $identifier);
    $alias_with_ampersand: _add-default-ampersand-if-context($modifier-name, $alias);
    $modifier: str-replace($modifier-name, ' &', '');

    @if _is-modifier-context-like($modifier-name) and $_is-sub-component-mode {
        @error $SPOT_ERROR_PREFIX + "register/sub-component-context - it is not allowed to register "+$modifier+"('"+$original-identifier+"') for sub-component '"+component()+"'. Register this "+$modifier+" in top parent component.";
    }

    @if _is-modifier-context-like($modifier-name) and $_is-child-component-mode {
        @error $SPOT_ERROR_PREFIX + "register/child-component-context - it is not allowed to register "+$modifier+"('"+$original-identifier+"') for child-component '"+component()+"'. Register this "+$modifier+" in top parent component.";
    }

    // create unique identifier of component+identifier
    $component-with-identifier: _get-component-identifier(component(), $identifier);

    // create unique modifier of component+modifier-name (without ' &' appendix)
    $component-with-modifier: str-replace(_get-component-modifier(component(), $modifier-name), ' &', '');

    // @feature Guarding duplicity of modifiers
    @if index($_registered-identifiers, $component-with-identifier) {
        @error $SPOT_ERROR_PREFIX + "register/duplicate-modifier - trying to register already registered modifier '"+$original-identifier+"' for component '"+component()+"'.";
    }

    // @feature Guarding duplicity of modifiers with aliases
    @if index($_registered-modifier-aliases, _get-component-identifier(component(), _normalize-alias($original-identifier))) {
        @error $SPOT_ERROR_PREFIX + "register/duplicate-modifier-with-alias - trying to register modifier '"+$original-identifier+"' but there is already registered modifier with same alias for component '"+component()+"'.";
    }

    // store unique identifier
    $_registered-identifiers: append($_registered-identifiers, $component-with-identifier) !global;

    @if $alias and $alias!='' and not $do-not-check-alias {
        // @feature Guarding duplicity of alias with modifiers
        @if index($_registered-identifiers, _get-component-identifier(component(), $alias_with_ampersand)) {
            @error $SPOT_ERROR_PREFIX + "register/duplicate-alias-with-modifier - trying to register alias '"+$alias+"' but there is already registered same modifier for component '"+component()+"'.";
        }

        // create unique identifier of component+identifier
        $component-with-alias: _get-component-identifier(component(), $alias);
    
        // @feature Guarding duplicity of modifiers aliases
        @if index($_registered-modifier-aliases, $component-with-alias) {
            @error $SPOT_ERROR_PREFIX + "register/duplicate-modifier-alias - trying to register already registered modifier alias '"+$alias+"' for component '"+component()+"'.";
        }

        // store unique alias
        $_registered-modifier-aliases: append($_registered-modifier-aliases, $component-with-alias) !global;    
    }
    
    // create empty map if does not existes yet
    @if not map-has-key($_registered-modifiers, $component-with-modifier) {
        $_registered-modifiers: map-merge($_registered-modifiers, ($component-with-modifier: ())) !global;
    }
    // get current map for given modifier
    $new-modifier: map-get($_registered-modifiers, $component-with-modifier);
    // add new modifier identifier
    $new-modifier: map-merge($new-modifier, ($identifier: (alias: $alias)));
    // merge it back to complex map
    $_registered-modifiers: map-merge($_registered-modifiers, ($component-with-modifier: $new-modifier)) !global; 
}


/// Reusable mixin for applying states, variants, contexts, browsers, responsive...
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variant' | 'context' | 'browser' | 'responsive'
/// @param { String } $args... - selector extension(s)
/// @content
/// @throw SPOT CSS: modifier/super-unknown-modifier - the modifier-name 'identifier' is not registered in any super component 'component'.
/// @throw SPOT CSS: modifier/super-modifier-not-found - the modifier-name 'identifier' is was not found on given super component index 'sub-component'.
/// @throw SPOT CSS: modifier/invalid-order - the modifier-name 'args' in component 'component' was used after sub element(s) which is not allowed. Put it higher before all child-element, sub-element and pseudo-element mixins.
/// @throw SPOT CSS: modifier/in-default - the modifier-name '$args' in component 'component' cannot by called in default mixin.
/// @throw SPOT CSS: modifier/default-is-missing - the modifier-name '$args' in component 'component' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).
/// @throw SPOT CSS: modifier/wrong-modifier-type - the modifier 'identifier' is not registered in component 'current selector' as 'modifier-name'. Check it out!
/// @throw SPOT CSS: modifier/unknown-modifier - the 'modifier-name' 'identifier' is not registered in component 'current selector'. Use mixin register + state() at first!
/// @output Selector extended by given extensions with given content.
@mixin _apply-modifier($modifier-name, $args...) {
    $selectors: ();
    $medias: ();
    $original-modifier-name: str-replace($modifier-name, ' &', '');
    $component: component();
    $component-to-extend: self();
    $is-super-modifier: str-index($modifier-name, 'super-')==1;
    $second-param-is-number: length($args)==2 and type-of(nth($args, 2))=='number';
    $second-param-index: '';
    $super-component-index: 0;
    @if $second-param-is-number { 
        $second-param-index: nth($args, 2); 
        $super-component-index: $second-param-index;
    }

    // for all non "super-" modifiers clear this index
    @if not $is-super-modifier {
        // clear this global variable
        $_super-component-index: null !global;
    }

    @if _is-modifier-context-like($modifier-name) {
        $component: top-component();
    }
    @else {
        // convert super-state and super-variant into modifier state and variant
        $modifier-name: str-replace($modifier-name, 'super-', '');
        $sub-component-stack: $_current-components;
        @if not $is-super-modifier {
            // changing logic to parse as super-modifier also state and variant, we add extra (useless) item here
            $sub-component-stack: append($_current-components, 'PLACEHOLDER_TO_REMOVE', 'space');
        }

        $found: false;
        $sub-component-name-for-error: '';
        // just find component only for first identifier (all others are expected on the same component)
        $identifier: first($args);

        // find $identifier in parent component
        @while not $found and length($sub-component-stack)>1 {
            @if $_super-component-index != null {
                $_super-component-index: $_super-component-index + 1 !global;
            }
            $sub-component-stack: pop($sub-component-stack);
            $component: #{$sub-component-stack};
            // if no index is given or current super component is given index
            @if $_super-component-index == null or $_super-component-index == 0 {                
                $sub-component-name-for-error: $component;
                $component-with-identifier: _get-component-identifier($component, $identifier);
                $component-with-modifier: str-replace(_get-component-modifier($component, $modifier-name), ' &', '');
                $modifiers: map-get($_registered-modifiers, $component-with-modifier);
                $is-alias: index($_registered-modifier-aliases, str-replace($component-with-identifier, ' &', ''));
                @if $is-alias or ($modifiers!=null and map-has-key($modifiers, $identifier)) {                    
                    @if $super-component-index < 0 {
                        $super-component-index: $super-component-index + 1;
                    }
                    @else {
                        $found: true;
                    }
                }
            }
        }
        @if not $found {
            @if $is-super-modifier or ($second-param-is-number and $second-param-index<0) {
                @if $_super-component-index == null {
                    @error $SPOT_ERROR_PREFIX + $original-modifier-name+"/super-unknown-modifier - the "+$original-modifier-name+" '"+$identifier+"' is not registered in any super component '"+&+"'.";
                }
                @else {
                    @error $SPOT_ERROR_PREFIX + $original-modifier-name+"/super-modifier-not-found - the "+$original-modifier-name+" '"+$identifier+"' is was not found on given super component index '"+$sub-component-name-for-error+"'.";
                }
            }
        }
        $component-to-extend: last($sub-component-stack);
    }
    $_current_modifier: $modifier-name !global;
    $component-to-extend-simplified: _remove-combinator-selector($component-to-extend);

    // check if sub elements mixin was not used for current selector
    @if index($_selectors-with-sub-elements, &) {
        @error $SPOT_ERROR_PREFIX + $original-modifier-name+"/invalid-order - the "+$original-modifier-name+" '"+inspect($args)+"' in component '"+$component+"' was used after sub element(s) which is not allowed. Put it higher before all child-element, sub-element and pseudo-element mixins.";
    }

    @if $_is-default-mode {
        @error $SPOT_ERROR_PREFIX + $original-modifier-name+"/in-default - the "+$original-modifier-name+" '"+inspect($args)+"' in component '"+component()+"' cannot by called in default mixin.";
    }

    // force using 'default' mixin when using modifiers
    @if not _default-mixin-was-already-called() and $_current-component-mode!='draft' {
        @error $SPOT_ERROR_PREFIX + $original-modifier-name+"/default-is-missing - the "+$original-modifier-name+" '"+inspect($args)+"' in component '"+$component+"' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).";
    }

    @if $second-param-is-number {
        $args: pop($args);
    }

    $current-modifier: $modifier-name + '(' + $args + ')';
    // add current modifier to the stack
    $current-modifier-stack: map-get($_current-modifiers-stack, $component); // for this component
    $current-modifier-stack-backup: $current-modifier-stack;
    $current-modifier-stack: append($current-modifier-stack, $current-modifier, 'comma');
    $_current-modifiers-stack: map-merge($_current-modifiers-stack, ($component: $current-modifier-stack)) !global;

    // log modifier to nested map of $_used-modifiers
    $modifier-pointer: map-get($_used-modifiers, $component);
    @if $modifier-pointer {
        $parents: []; 
        @each $modifier in $current-modifier-stack {
            @if not map-has-key($modifier-pointer, $modifier) {
                $modifier-pointer: map-merge($modifier-pointer, ($modifier: ()));
            }
            $parents: append($parents, $modifier-pointer, 'comma');
            $modifier-pointer: map-get($modifier-pointer, $modifier);
        }
        $map: ();
        @while length($parents)>0 {
            $i: length($parents);
            $name: nth($current-modifier-stack, $i);
            $last: nth($parents, $i);
            $map: map-merge($last, ($name: $map));
            $parents: nth-delete($parents, -1);
        }
        $_used-modifiers: map-merge($_used-modifiers, ($component: $map)) !global;
    }

    // create index of already used modifiers
    $checklist-of-used-modifiers: map-get($_checklist-of-used-modifiers, $component);
    @if $checklist-of-used-modifiers==null { $checklist-of-used-modifiers: (); }
    
    // generate selectors for all args
    @each $identifier in $args {
        $original-identifier: $identifier;
        $identifier: _add-default-ampersand-if-context($modifier-name, $identifier);
        $component-with-identifier-alias: _get-component-identifier($component, _normalize-alias($identifier));
        $component-with-modifier: str-replace(_get-component-modifier($component, $modifier-name), ' &', '');
        $modifiers: map-get($_registered-modifiers, $component-with-modifier);
        $is-alias: index($_registered-modifier-aliases, str-replace($component-with-identifier-alias, ' &', ''));
        @if $is-alias {
            @if $modifiers {
                // find all modifiers with this alias
                @each $modifier in $modifiers {
                    $alias: map-get(nth($modifier, 2), 'alias');
                    @if $alias==_normalize-alias($original-identifier) {
                        $extension: nth($modifier, 1);
                        $extended-selector: '';
                        @if str-index($extension, '@media')==1 {
                            $medias: append($medias, str-replace(str-replace($extension, '@media ', ''), ' &', ''), 'comma');
                        }
                        @else {   
                            @if str-index($extension, '&') {
                                $context-extension: str-replace($extension, ' &', '');
                                $extended-selector: merge-selectors($context-extension, &);
                            }
                            @else {
                                $extended-selector: extend(&, $component-to-extend-simplified, $extension);
                            }
                            $selectors: append($selectors, $extended-selector, 'comma');
                        }
                        // create index of already used modifiers
                        $checklist-of-used-modifiers: map-merge($checklist-of-used-modifiers, ($original-modifier-name+' '+$extension: true));
                    }
                }
            }
            @if length($selectors)==0 and length($medias)==0 {
                // @feature Forcing to register all modifiers at first
                @error $SPOT_ERROR_PREFIX + $original-modifier-name+"/wrong-modifier-type - the modifier '"+$identifier+"' is not registered in component '"+&+"' as "+$modifier-name+". Check it out!";
            }
        }
        // if not alias - just $identifier
        @else {
            @if ($modifiers!=null and map-has-key($modifiers, $identifier)) or $_current-component-mode=='draft' {
                $extension: $identifier;
                $extended-selector: '';
                @if str-index($extension, '@media')==1 {
                    $medias: append($medias, str-replace(str-replace($extension, '@media ', ''), ' &', ''), 'comma');
                }
                @else {          
                    @if str-index($extension, '&') {
                        $context-extension: str-replace($extension, ' &', '');
                        $extended-selector: merge-selectors($context-extension, &);
                    }
                    @else {
                        $extended-selector: extend(&, $component-to-extend-simplified, $extension);
                    }
                    $selectors: append($selectors, $extended-selector, 'comma');
                }
                // create index of already used modifiers
                $checklist-of-used-modifiers: map-merge($checklist-of-used-modifiers, ($original-modifier-name+' '+$extension: true));
            }
            @else {
                // @feature Forcing to register all modifiers at first
                @error $SPOT_ERROR_PREFIX + $original-modifier-name+"/unknown-modifier - the "+$original-modifier-name+" '"+$identifier+"' is not registered in component '"+&+"'. Use mixin register state() at first!";
            }
        }
    }
    
    // create index of already used modifiers
    $_checklist-of-used-modifiers: map-merge($_checklist-of-used-modifiers, ($component: $checklist-of-used-modifiers)) !global;

    // for purpose of mixin only-for 
    $_already-used-multiple-selectors: append($_already-used-multiple-selectors, $selectors) !global;

    // check all selectors if wasn't used already
    $i: 0;
    // for super-state|variant add index string to distinct already used state
    @if $second-param-index!='' { $second-param-index: '[['+$second-param-index+']]'; }
    @each $single-selector in $selectors {
        $i: $i + 1;
        $single-selector: _wrap-into-media-selector( str-replace($single-selector+'', '&', &) )+$second-param-index;
        @if index($_already-used-selectors, $single-selector) {
            @error $SPOT_ERROR_PREFIX + $original-modifier-name+"/already-used-modifier - the "+$original-modifier-name+"('" + nth($args,$i) + "') is already used somewhere higher! Do not break the SPOT rule and use just single place for every variant "+$modifier-name+".";
        }
        $_already-used-selectors: append($_already-used-selectors, $single-selector) !global;
    }

    $_is-modifier-mode: true !global;

    @if length($medias)>0 {
        // store current media selector (into stack)
        $_current-media-stack: append($_current-media-stack, $medias, 'space') !global;
        
        @media #{$medias} {
            @content;
        }        
        // remove current media selector (from stack)
        $_current-media-stack: pop($_current-media-stack) !global;
    }

    @if length($selectors)>0 {
        @at-root #{$selectors} {
            @content;
        }
    }
    // remove current modifier from the stack
    $_current-modifiers-stack: map-merge($_current-modifiers-stack, ($component: $current-modifier-stack-backup)) !global;

    $_is-modifier-mode: false !global;
}


/// Sets flag that register was already called in component.
/// @access private
/// @output Nothing.
@mixin _set_register-mixin-was-already-called() {
    $_register-called-on: append($_register-called-on, component()) !global;
}


/// Sets flag that default was already called in current selector.
/// @access private
/// @output Nothing.
@mixin _set_default-mixin-was-already-called() {
    $_default-called-on: append($_default-called-on, component()) !global;
}


/// Declares direct child block in current component selector.
/// @group Component
/// @access private
/// @param { String } $sub-element-type - Name of modifier: 'child', 'sub' or 'pseudo'
/// @param { String } $selectors... - One or more selectors of direct childs. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: {sub}-element/no-selectors - at least one {sub} selector is expected.
/// @throw SPOT CSS: {sub}-element/in-modifier - it is not allowed to use {sub}-element in modifier 'modifier'.
/// @throw SPOT CSS: {sub}-element/in-default - it is not allowed to call {sub}-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: {sub}-element/missing-separator - there is sub-element separator mixin (_______) missing before {sub}-element mixin in component ('component').
/// @throw SPOT CSS: {sub}-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: {sub}-element/multilevel-selector - given selector is not a single selector ('selector'). Just use more {sub}-element mixins nested.
/// @throw SPOT CSS: pseudo-element/invalid-selector - Invalid value for pseudo element 'selector'. Only valid values are 'before', 'after' and other pseudo elements.
/// @throw SPOT CSS: {sub}-element/already-registered - trying to register already registered sub-element 'selector' for component selector 'current-selector'.
/// @throw SPOT CSS: {sub}-element/unregistred-sub-element - the {sub}-element('selector') is not registered for component selector 'component()'.
/// @throw SPOT CSS: {sub}-element/already-used - the {sub}-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every {sub}-element.
/// @throw SPOT CSS: {sub}-element-alias/already-registered - trying to register already registered sub-element '{alias}' for component selector '{selector}'.
/// @throw SPOT CSS: {sub}-element-alias/unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @output Given selector with given content.
@mixin _sub-element($sub-element-type, $sub-selectors...) {
    @if length($sub-selectors)==0 {
        @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/no-selectors - at least one "+$sub-element-type+" selector is expected.";
    }
    // do not allow in modifier
    @if $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/in-modifier - it is not allowed to use "+$sub-element-type+"-element in modifier '"+$_current_modifier+"'.";
    }

    @if $_is-default-mode {
        @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/in-default - it is not allowed to call "+$sub-element-type+"-element mixin in default mixin (in component '"+component()+"').";
    }
    // check for separator
    @if not $_is-register-mode and not $_was-used-sub-element-separator {
        @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/missing-separator - there is sub-element separator mixin (_______) missing before "+$sub-element-type+"-element mixin in component ('"+component()+"').";
    }
    $_was-used-sub-element-separator: false !global;

    @if not $_is-register-mode {
        // store appling sub element in current selector to avoid calling state, variant, etc. after that
        @if not index($_selectors-with-sub-elements, &) {
            $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
        }
    }

    $counter: 0;
    $selectors-without-alias: shift($sub-selectors); // remove first item (alias)

    $alias: null;
    $component-alias-key: null;
    $registered-component-alias: null;

    @if _is-alias(first($sub-selectors)) {
        $alias: _normalize-alias(first($sub-selectors));
        $component-alias-key: top-component()+' '+$alias;

        @if $_is-register-mode {
            $sub-selectors: shift($sub-selectors);
            $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
            $registered-component-element-alias: map-get($_registered-component-element-aliases, $component-alias-key);

            // guarding duplicity of sub-elements alias (for whole component)
            @if $registered-component-alias and (($registered-component-element-alias and str-index(&+'', $registered-component-element-alias+'')==1) or $registered-component-alias!=$selectors-without-alias) {
                @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element-alias/already-registered - trying to register already registered sub-element '"+$alias+"' for component selector '"+&+"'.";
            }
            
            $registered-component-alias: $selectors-without-alias;
            $_registered-component-aliases: map-merge($_registered-component-aliases, ($component-alias-key: $registered-component-alias)) !global;
            $_registered-component-element-aliases: map-merge($_registered-component-element-aliases, ($component-alias-key: &)) !global;
        }
    }

    @if not $_is-register-mode {
        // expand aliases to selectors
        @for $i from 1 through length($sub-selectors) {
            $selector: nth($sub-selectors, $i);
            @if _is-alias($selector) {
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                
                @if not $registered-component-alias {
                    @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element-alias/unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
                }

                $sub-selectors: replace-nth($sub-selectors, $i, $registered-component-alias);
            }
        }
    }

    $selectors: (); 
    @each $selector in $sub-selectors {
        $parts: selector-parse($selector);
        // @feature Forcing using only single selector in one selector string. It could be passed more selectors in separate arguments.
        @if length($parts)>1 {
            @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/single-selector - given selector is not a single selector ('"+$selector+"'). Just pass it as a separate argument.";
        }
        @if $sub-element-type == 'sub' {    
            $selector: & + ' ' + $selector;
        }  
        @if $sub-element-type == 'child' {    
            // all child selectors must start with >
            @if str-index(str-trim-left($selector), '>')!=1 and str-last-char(#{&})!='>' {
                $selector: ' > '+$selector;
            }
            @else {
                // unify ' > ' with spaces
                $selector: selector-normalize-spaces($selector);
            }
            // @feature Guarding that only first (one) level child selector is passed.
            // Value 2 because also starting '>' is counted
            @if length-of-simple-selector($selector)>2 {
                @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/multilevel-selector - given selector is not a single selector ('"+$selector+"'). Just use more "+$sub-element-type+"-element mixins nested.";
            }
            $selector: & + $selector;
        }
        @if $sub-element-type == 'pseudo' {
            // replace all colons (':' and '::')
            $pseudo-selector: str-trim(str-replace(str-replace($selector, '::', ''), ':', ''));

            // supports also "-" prefix e.g. ::-webkit-scrollbar
            @if contains-pseudo-element('::'+$pseudo-selector)==false {
                @error $SPOT_ERROR_PREFIX + "pseudo-element/invalid-selector - Invalid value for pseudo element '"+$pseudo-selector+"'. Only valid values are 'before', 'after' and other pseudo elements.";
            }

            $selector: & + '::' + $pseudo-selector;
        }

        @if $_is-register-mode {
            // guarding duplicity of sub-elements
            @if index($_registered-sub-elements, $selector) {
                @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/already-registered - trying to register already registered sub-element '"+$selector+"' for component selector '"+&+"'.";
            }            
            // store unique sub-component
            $_registered-sub-elements: append($_registered-sub-elements, $selector, 'comma') !global;
        }
        @else {
            @if $sub-element-type == 'child' {
                // unify ' > ' with spaces
                $selector: selector-normalize-spaces($selector);
            }

            @if not index($_registered-sub-elements, $selector) and $_current-component-mode!='draft' {
                @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/unregistred-sub-element - the "+$sub-element-type+"-element('" + $selector + "') is not registered for component selector '"+component()+"'.";
            }

            @if index($_already-used-selectors, $selector) {
                @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/already-used - the "+$sub-element-type+"-element('" + $selector + "') is already used somewhere higher! Do not break the SPOT rule and use just single place for every "+$sub-element-type+"-element.";
            }
            $_already-used-selectors: append($_already-used-selectors, $selector) !global;
        }
        
        $selectors: append($selectors, $selector, 'comma');
    }

    @at-root
    #{$selectors} {
        @content;
    }
}


/// Mixin supporting super-state and super-variant mixin.
/// @group Component
/// @access private
/// @param { String } $modifier-name - Name of modifier: 'super-state' or 'super-variant'
/// @param { String } $args... - One or more selectors of direct childs. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: super-{modifier}/in-register - the mixin super-{modifier} doesn't have to be registered in register mixin in component 'component'. It is already registered in parent component.
/// @throw SPOT CSS: super-{modifier}/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: super-{modifier}/sub-component - super-{modifier} can be used only in sub-component.
/// @output Extended super component selector with given content.
@mixin _super-modifier($modifier-name, $args...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + $modifier-name+"/in-register - the mixin "+$modifier-name+" doesn't have to be registered in register mixin in component '"+component()+"'. It is already registered in parent component.";
    }

    @if length($args)==0 {
        @error $SPOT_ERROR_PREFIX + $modifier-name+"/no-selector - selector was expected but nothing passed.";
    }

    @if length($_current-components)<2 {
        @error $SPOT_ERROR_PREFIX + $modifier-name+"/sub-component - "+$modifier-name+" can be used only in sub-component.";
    }

    // clear this global variable
    $_super-component-index: null !global;

    // if index of super component is given as first argument
    @if type-of(first($args))=='number' {
        $index: first($args);
        @if $index > 0 {
            // convert positive number (reverse index - from start) to negative value
            $len: length($_current-components);
            $index: ($len - $index) * -1;
        }
        $_super-component-index: $index !global;
        $args: nth-delete($args, 1);
    }

    @include _apply-modifier($modifier-name, $args...) {
        @content;
    }
}


/// Mandatory separator (________) before each sub-element modifier.
/// @group Component
/// @access private
@mixin _sub-element-separator {
    $_was-used-sub-element-separator: true !global;
}


/// Checks if component used all registered (sub)elements (called from component mixin at the end).
@mixin _check-if-all-sub-elements-were-used($component) {
    // @debug $_already-used-multiple-selectors;
    // for all (sub)elements (a.k.a. sub-components) check mutations
    $registered-sub-components: map-get($_registered-sub-components, $component);
    @if $registered-sub-components!=null {
        @each $sub-component in $registered-sub-components {            
            @if index($_already-used-multiple-selectors, $sub-component)==null {
                @warn $SPOT_ERROR_PREFIX + "component/unused-element - element '"+$sub-component+"' was registered but never used (in component '"+$component+"').";
            }
        }
    }
}

/// Checks if component used all registered mutations (called from component mixin at the end).
@mixin _check-if-all-mutations-were-used($component) {
    $checklist-of-used-modifiers: map-get($_checklist-of-used-modifiers, $component);
    @if $checklist-of-used-modifiers==null { $checklist-of-used-modifiers: (); }

    @each $modifier-type in $_all_types_of_modifiers {
        $mutations: _get-component-modifiers(component(), $modifier-type);
        @if $mutations {
            @each $mutation, $mutation-params in $mutations {
                @if map-get($checklist-of-used-modifiers, $modifier-type+' '+$mutation)==null {
                    @warn $SPOT_ERROR_PREFIX + "component/unused-mutation - "+$modifier-type+" '"+$mutation+"' was registered but never used (in component '"+$component+"').";
                }
            }
        }   
    }

    // for all (sub)elements (a.k.a. sub-components) check mutations
    $registered-sub-components: map-get($_registered-sub-components, $component);
    @if $registered-sub-components!=null {
        @each $sub-component in $registered-sub-components {
            $checklist-of-used-modifiers: map-get($_checklist-of-used-modifiers, $sub-component);
            @if $checklist-of-used-modifiers==null { $checklist-of-used-modifiers: (); }

            @each $modifier-type in $_all_types_of_modifiers {
                $mutations: _get-component-modifiers($sub-component, $modifier-type);
                @if $mutations {
                    @each $mutation, $mutation-params in $mutations {
                        @if map-get($checklist-of-used-modifiers, $modifier-type+' '+$mutation)==null {
                            @warn $SPOT_ERROR_PREFIX + "component/unused-mutation - "+$modifier-type+" '"+$mutation+"' was registered but never used (in '"+$component+"').";
                        }
                    }
                }   
            }
        }
    }
}



/// guarding duplicity of sub-selectors
@mixin _check-duplicity-of-sub-selectors($node-type, $whole-selector, $registering-end-selector) {
    $registered-sub-components: map-get($_registered-sub-components, top-component());
    @if $registered-sub-components==null { $registered-sub-components: []; }

    @if index($_already-used-selectors, $whole-selector) or index($registered-sub-components, $whole-selector) {
        @error $SPOT_ERROR_PREFIX + $node-type+"/already-registered - trying to register already registered element '"+$registering-end-selector+"' to '"+component()+"'.";
    }
    // store unique sub-component
    $_already-used-selectors: append($_already-used-selectors, $whole-selector, 'comma') !global;
    $registered-sub-components: append($registered-sub-components, $whole-selector, 'comma');
    $_registered-sub-components: map-merge($_registered-sub-components, (top-component(): $registered-sub-components)) !global;
}
