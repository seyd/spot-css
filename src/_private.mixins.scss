/// Reusable mixin for registering states, variants, contexts, browsers, responsive...
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variant' | 'context' | 'browser' | 'responsive'
/// @param { String } $identifier - selector extension
/// @param { String } $args... - extra arguments for input values for placeholder '?' or alias name when context-like modifier ('context' | 'browser' | 'responsive')
/// @throw SPOT CSS: register/invalid-selector-extension - the mixin register { modifier-name(identifier) } uses invalid selector extension 'identifier'. The extension can start only with one of these characters: '.', '#', '@', '[', ':' (or '?' or '{' when placeholder is used).
/// @throw SPOT CSS: register/no-component - the mixin register { modifier-name(identifier) } must be used inside a component selector.
/// @throw SPOT CSS: register/missing-values - the mixin register { modifier-name(identifier) } uses '?' as value placeholder but no values were provided.
/// @throw SPOT CSS: register/extra-values - the mixin register { modifier-name(identifier) } doesn't use '?' as value placeholder but extra values were provided.
/// @output Nothing.
@mixin _register-modifiers($modifier-name, $identifier, $args...) { 
    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "register/no-component - the mixin register { "+$modifier-name+"("+$identifier+") } must be used inside a component selector.";
    }

    // mark flag that some modifier was called in register mixin
    $_is-called-something-in-register: true !global;

    // is context-like (context, browser or responsive) or vriation-like (state or variant)
    $is-context-like: str-index($modifier-name, '&');

    // for variant-like selector extensions only valid first chars are: . # [ : (or '?' or '{' when placeholder is used)
    @if not $is-context-like {
        $first-char: str-slice(str-trim-left($identifier), 1, 1);
        @if $first-char!='.' and $first-char!='#' and $first-char!='[' and $first-char!=':' and $first-char!='?' and $first-char!='{' and $first-char!='@' {
            @error $SPOT_ERROR_PREFIX + "register/invalid-selector-extension - the mixin register { "+$modifier-name+"("+$identifier+") } uses invalid selector extension '"+$identifier+"'. The extension can start only with one of these characters: '.', '#', '@', [', ':' (or '?' or '{' when placeholder is used).";
        }
    }

    // if selector contains '?' (e.g. '[type="?"]') character, $args must be provided as expected values
    // expample arguments: ('state', '[type="?"]', 'primary', 'secondary')
    @if str-index($identifier, '?') or str-index($identifier, '{') {
        $len: length($args);
        @if $len==0 {
            @error $SPOT_ERROR_PREFIX + "register/missing-values - the mixin register { "+$modifier-name+"("+$identifier+") } uses '?' as value placeholder but no values were provided.";
        }
        @else {
            $alias: $identifier;
            $placeholder-start: str-index($identifier, '?') or str-index($identifier, '{');
            $placeholder-end: str-index($identifier, '?') or str-index($identifier, '}');
            // register modifier for each given value individualy
            @for $i from 1 through $len {                 
                $selector: str-slice($identifier, 1, $placeholder-start - 1) + nth($args, $i) + str-slice($identifier, $placeholder-end + 1 );
                @include _register-individual-modifier($modifier-name, $selector, $alias, $do-not-check-alias: $i!=1); // check alias only for first modifier
            }
        }
    }
    // if selector does not contains "?" or "{" character, $args must be not provided (as expected values)
    @else {
        // if extra values
        @if $args!=null and length($args)!=0 {
            @error $SPOT_ERROR_PREFIX + "register/extra-values - the mixin register { "+$modifier-name+"("+$identifier+") } doesn't use '?' as value placeholder but extra values were provided.";
        }
        @else {
            // register modifier
            @include _register-individual-modifier($modifier-name, $identifier, $args...);
        }
    }
}


/// Reusable mixin for registering state, variant, context, browser or responsive.
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variant' | 'context' | 'browser' | 'responsive'
/// @param { String } $identifier - selector extension
/// @param { String } $alias - alias name when context-like modifier ('context' | 'browser' | 'responsive')
/// @param { Bool } $do-not-check-alias - flag to skip duplicity check for aliases
/// @throw SPOT CSS: register/sub-component-context - it is not allowed to register modifier(identifier) for sub-component 'component'. Register this 'modifier' in top parent component.
/// @throw SPOT CSS: register/duplicate-modifier - trying to register already registered modifier 'identifier' for component 'component'.
/// @throw SPOT CSS: register/duplicate-modifier-with-alias - trying to register modifier 'identifier' but there is already registered modifier with same alias for component 'component'.
/// @throw SPOT CSS: register/duplicate-alias-with-modifier - trying to register alias 'alias' but there is already registered same modifier for component 'component'.
/// @throw SPOT CSS: register/duplicate-modifier-alias - trying to register already registered modifier alias 'alias' for component 'component'.
/// @output Nothing.
@mixin _register-individual-modifier($modifier-name, $identifier, $alias: '', $do-not-check-alias: false) {    
    // backup
    $original-identifier: $identifier;    

    $identifier: _add-default-ampersand-if-context($modifier-name, $identifier);
    $alias_with_ampersand: _add-default-ampersand-if-context($modifier-name, $alias);
    $modifier: str-replace($modifier-name, ' &', '');

    $current-component: component();; 

    @if _is-modifier-context-like($modifier-name) and $_is-sub-component-mode {
        @error $SPOT_ERROR_PREFIX + "register/sub-component-context - it is not allowed to register "+$modifier+"('"+$original-identifier+"') for sub-component '"+$current-component+"'. Register this "+$modifier+" in top parent component.";
    }

    // create unique identifier of component+identifier
    $component-with-identifier: _get-component-identifier($current-component, $identifier);

    // create unique modifier of component+modifier-name (without ' &' appendix)
    $component-with-modifier: str-replace(_get-component-modifier($current-component, $modifier-name), ' &', '');

    // @feature Guarding duplicity of modifiers
    @if index($_registered-identifiers, $component-with-identifier) {
        @error $SPOT_ERROR_PREFIX + "register/duplicate-modifier - trying to register already registered modifier '"+$original-identifier+"' for component '"+$current-component+"'.";
    }

    // @feature Guarding duplicity of modifiers with aliases
    @if index($_registered-aliases, _get-component-identifier($current-component, $original-identifier)) {
        @error $SPOT_ERROR_PREFIX + "register/duplicate-modifier-with-alias - trying to register modifier '"+$original-identifier+"' but there is already registered modifier with same alias for component '"+$current-component+"'.";
    }

    // store unique identifier
    $_registered-identifiers: append($_registered-identifiers, $component-with-identifier) !global;

    @if $alias and $alias!='' and not $do-not-check-alias {
        // @feature Guarding duplicity of alias with modifiers
        @if index($_registered-identifiers, _get-component-identifier($current-component, $alias_with_ampersand)) {
            @error $SPOT_ERROR_PREFIX + "register/duplicate-alias-with-modifier - trying to register alias '"+$alias+"' but there is already registered same modifier for component '"+$current-component+"'.";
        }

        // create unique identifier of component+identifier
        $component-with-alias: _get-component-identifier($current-component, $alias);
    
        // @feature Guarding duplicity of modifiers aliases
        @if index($_registered-aliases, $component-with-alias) {
            @error $SPOT_ERROR_PREFIX + "register/duplicate-modifier-alias - trying to register already registered modifier alias '"+$alias+"' for component '"+$current-component+"'.";
        }

        // store unique alias
        $_registered-aliases: append($_registered-aliases, $component-with-alias) !global;    
    }
    
    // create empty map if does not existes yet
    @if not map-has-key($_registered-modifiers, $component-with-modifier) {
        $_registered-modifiers: map-merge($_registered-modifiers, ($component-with-modifier: ())) !global;
    }
    // get current map for given modifier
    $new-modifier: map-get($_registered-modifiers, $component-with-modifier);
    // add new modifier identifier
    $new-modifier: map-merge($new-modifier, ($identifier: (alias: $alias)));
    // merge it back to complex map
    $_registered-modifiers: map-merge($_registered-modifiers, ($component-with-modifier: $new-modifier)) !global; 
}


/// Reusable mixin for applying states, variants, contexts, browsers, responsive...
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variant' | 'context' | 'browser' | 'responsive'
/// @param { String } $args... - selector extension(s)
/// @content
/// @throw SPOT CSS: modifier/invalid-order - the modifier-name 'args' in component 'component' was used after sub element(s) which is not allowed. Put it higher before all child-element, sub-element and pseudo-element mixins.
/// @throw SPOT CSS: modifier/in-default - the modifier-name '$args' in component 'component' cannot by called in default mixin.
/// @throw SPOT CSS: modifier/default-is-missing - the modifier-name '$args' in component 'component' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).
/// @throw SPOT CSS: modifier/wrong-modifier-type - the modifier 'identifier' is not registered in component 'current selector' as 'modifier-name'. Check it out!
/// @throw SPOT CSS: modifier/unknown-modifier - the 'modifier-name' 'identifier' is not registered in component 'current selector'. Use mixin register + state() at first!
/// @output Selector extended by given extensions with given content.
@mixin _apply-modifier($modifier-name, $args...) {
    $selectors: ();
    $medias: ();
    $component: '';
    @if _is-modifier-context-like($modifier-name) {
        $component: top-component();
    }
    @else {
        $component: component();
    }
    $_current_modifier: $modifier-name !global;

    // check if sub elements mixin was not used for current selector
    @if index($_selectors-with-sub-elements, &) {
        @error $SPOT_ERROR_PREFIX + "modifier/invalid-order - the "+$modifier-name+" '"+inspect($args)+"' in component '"+$component+"' was used after sub element(s) which is not allowed. Put it higher before all child-element, sub-element and pseudo-element mixins.";
    }

    @if $_is-default-mode {
        @error $SPOT_ERROR_PREFIX + "modifier/in-default - the "+$modifier-name+" '"+inspect($args)+"' in component '"+component()+"' cannot by called in default mixin.";
    }

    // force using 'default' mixin when using modifiers
    @if not _default-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "modifier/default-is-missing - the "+$modifier-name+" '"+inspect($args)+"' in component '"+$component+"' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).";
    }

    $current-modifier: $modifier-name + '(' + $args + ')';
    // add current modifier to the stack
    $current-modifier-stack: map-get($_current-modifiers-stack, $component); // for this component
    $current-modifier-stack-backup: $current-modifier-stack;
    $current-modifier-stack: append($current-modifier-stack, $current-modifier, 'comma');
    $_current-modifiers-stack: map-merge($_current-modifiers-stack, ($component: $current-modifier-stack)) !global;

    // log modifier to nested map
    $modifier-pointer: map-get($_used-modifiers, $component);
    @if $modifier-pointer {
        $parents: []; 
        @each $modifier in $current-modifier-stack {
            @if not map-has-key($modifier-pointer, $modifier) {
                $modifier-pointer: map-merge($modifier-pointer, ($modifier: ()));
            }
            $parents: append($parents, $modifier-pointer, 'comma');
            $modifier-pointer: map-get($modifier-pointer, $modifier);
        }
        $map: ();
        @while length($parents)>0 {
            $i: length($parents);
            $name: nth($current-modifier-stack, $i);
            $last: nth($parents, $i);
            $map: map-merge($last, ($name: $map));
            $parents: nth-delete($parents, -1);
        }
        $_used-modifiers: map-merge($_used-modifiers, ($component: $map)) !global;
    }

    // generate selectors for all args
    @each $identifier in $args {
        $original-identifier: $identifier;
        $identifier: _add-default-ampersand-if-context($modifier-name, $identifier);
        $component-with-identifier: _get-component-identifier($component, $identifier);
        $component-with-modifier: str-replace(_get-component-modifier($component, $modifier-name), ' &', '');
        $modifiers: map-get($_registered-modifiers, $component-with-modifier);
        $is-alias: index($_registered-aliases, str-replace($component-with-identifier, ' &', ''));
        @if $is-alias {
            @if $modifiers {
                // find all modifiers with this alias
                @each $modifier in $modifiers {
                    $alias: map-get(nth($modifier, 2), 'alias');
                    @if $original-identifier==$alias {
                        $extension: nth($modifier, 1);
                        $extended-selector: '';
                        @if str-index($extension, '@media')==1 {
                            $medias: append($medias, str-replace(str-replace($extension, '@media ', ''), ' &', ''), 'comma');
                        }
                        @else {   
                            @if str-index($extension, '&') {
                                $context-extension: str-replace($extension, ' &', '');
                                $extended-selector: merge-selectors($context-extension, &);
                            }
                            @else {
                                $extended-selector: extend(&, self(), $extension);
                            }
                            $selectors: append($selectors, $extended-selector, 'comma');
                        }
                    }                
                }
            }
            @if length($selectors)==0 and length($medias)==0 {
                // @feature Forcing to register all modifiers at first
                @error $SPOT_ERROR_PREFIX + "modifier/wrong-modifier-type - the modifier '"+$identifier+"' is not registered in component '"+&+"' as "+$modifier-name+". Check it out!";
            }
        }
        // if not alias - just $identifier
        @else {
            @if $modifiers!=null and map-has-key($modifiers, $identifier) {
                $extension: $identifier;
                $extended-selector: '';
                @if str-index($extension, '@media')==1 {
                    $medias: append($medias, str-replace(str-replace($extension, '@media ', ''), ' &', ''), 'comma');
                }
                @else {          
                    @if str-index($extension, '&') {
                        $context-extension: str-replace($extension, ' &', '');
                        $extended-selector: merge-selectors($context-extension, &);
                    }
                    @else {
                        $extended-selector: extend(&, self(), $extension);
                    }
                    $selectors: append($selectors, $extended-selector, 'comma');
                }
            }
            @else {
                // @feature Forcing to register all modifiers at first
                @error $SPOT_ERROR_PREFIX + "modifier/unknown-modifier - the "+$modifier-name+" '"+$identifier+"' is not registered in component '"+&+"'. Use mixin register state() at first!";
            }
        }
    } 

    // for purpose of mixin only-for 
    $_already-used-multiple-selectors: append($_already-used-multiple-selectors, $selectors) !global;

    // check all selectors if wasn't used already
    $i: 0;
    @each $single-selector in $selectors {
        $i: $i + 1;
        $single-selector: _wrap_into_media_selector( str-replace($single-selector+'', '&', &) );
        @if index($_already-used-selectors, $single-selector) {
            @error $SPOT_ERROR_PREFIX + "modifier/already-used-modifier - the "+$modifier-name+"('" + nth($args,$i) + "') is already used somewhere higher! Do not break the SPOT rule and use just single place for every variant "+$modifier-name+".";
        }
        $_already-used-selectors: append($_already-used-selectors, $single-selector) !global;
    }

    $_is-modifier-mode: true !global;

    @if length($medias)>0 {
        // store current media selector (into stack)
        $_current-media-stack: append($_current-media-stack, $medias, 'space') !global;
        
        @media #{$medias} {
            @content;
        }        
        // remove current media selector (from stack)
        $_current-media-stack: pop($_current-media-stack) !global;
    }

    @if length($selectors)>0 {
        @at-root #{$selectors} {
            @content;
        }
    }
    // remove current modifier from the stack
    $_current-modifiers-stack: map-merge($_current-modifiers-stack, ($component: $current-modifier-stack-backup)) !global;

    $_is-modifier-mode: false !global;
}


/// Sets flag that register was already called in component.
/// @access private
/// @output Nothing.
@mixin _set_register-mixin-was-already-called() {
    $_register-called-on: append($_register-called-on, component()) !global;
}


/// Sets flag that default was already called in current selector.
/// @access private
/// @output Nothing.
@mixin _set_default-mixin-was-already-called() {
    $_default-called-on: append($_default-called-on, component()) !global;
}


/// Declares direct child block in current component selector.
/// @group Component
/// @access private
/// @param { String } $sub-element-type - Name of modifier: 'child', 'sub' or 'pseudo'
/// @param { String } $selectors... - One or more selectors of direct childs. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: {sub}-element/no-selectors - at least one {sub} selector is expected.
/// @throw SPOT CSS: {sub}-element/in-modifier - it is not allowed to use {sub}-element in modifier 'modifier'.
/// @throw SPOT CSS: {sub}-element/in-default - it is not allowed to call {sub}-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: {sub}-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: {sub}-element/multilevel-selector - given selector is not a single selector ('selector'). Just use more {sub}-element mixins nested.
/// @throw SPOT CSS: pseudo-element/invalid-selector - Invalid value for pseudo element 'selector'. Only valid values are 'before', 'after', 'first-letter', 'first-line', 'placeholder' or 'selection'.
/// @throw SPOT CSS: {sub}-element/already-used - the {sub}-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every {sub}-element.
/// @output Given selector with given content.
@mixin _sub-element($sub-element-type, $sub-selectors...) {
    @if length($sub-selectors)==0 {
        @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/no-selectors - at least one "+$sub-element-type+" selector is expected.";
    }
    // do not allow in modifier
    @if $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/in-modifier - it is not allowed to use "+$sub-element-type+"-element in modifier '"+$_current_modifier+"'.";
    }

    @if $_is-default-mode {
        @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/in-default - it is not allowed to call "+$sub-element-type+"-element mixin in default mixin (in component '"+component()+"').";
    }

    @if $_is-register-mode {
        // mark flag that some modifier was called in register mixin
        $_is-called-something-in-register: true !global;
    }
    @else {
        // store appling sub element in current selector to avoid calling state, variant, etc. after that
        @if not index($_selectors-with-sub-elements, &) {
            $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
        }
    }

    $selectors: (); 
    @each $selector in $sub-selectors {
        $parts: selector-parse($selector);
        // @feature Forcing using only single selector in one selector string. It could be passed more selectors in separate arguments.
        @if length($parts)>1 {
            @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/single-selector - given selector is not a single selector ('"+$selector+"'). Just pass it as a separate argument.";
        }
        @if $sub-element-type == 'sub' {    
            $selector: & + ' ' + $selector;
        }  
        @if $sub-element-type == 'child' {    
            // all child selectors must start with >
            @if str-index(str-trim-left($selector), '>')!=1 and str-last-char(#{&})!='>' {
                $selector: '> '+$selector;
            }
            // @feature Guarding that only first (one) level child selector is passed.
            // Value 2 because also starting '>' is counted
            @if length-of-simple-selector($selector)>2 {
                @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/multilevel-selector - given selector is not a single selector ('"+$selector+"'). Just use more "+$sub-element-type+"-element mixins nested.";
            }
            $selector: & + $selector;
        }
        @if $sub-element-type == 'pseudo' {
            // replace all colons (':' and '::')
            $pseudo-selector: str-trim(str-replace(str-replace($selector, '::', ''), ':', ''));

            @if $pseudo-selector!='before' and $pseudo-selector!='after' and $pseudo-selector!='first-letter' and $pseudo-selector!='first-line' and $pseudo-selector!='placeholder' and $pseudo-selector!='selection' {
                @error $SPOT_ERROR_PREFIX + "pseudo-element/invalid-selector - Invalid value for pseudo element '"+$pseudo-selector+"'. Only valid values are 'before', 'after', 'first-letter', 'first-line', 'placeholder' or 'selection'.";
            }

            $selector: & + '::' + $pseudo-selector;
        }

        @if not $_is-register-mode {
            @if index($_already-used-selectors, $selector) {
                @error $SPOT_ERROR_PREFIX + $sub-element-type + "-element/already-used - the "+$sub-element-type+"-element('" + $selector + "') is already used somewhere higher! Do not break the SPOT rule and use just single place for every "+$sub-element-type+"-element.";
            }
            $_already-used-selectors: append($_already-used-selectors, $selector) !global;
        }
        
        $selectors: append($selectors, $selector, 'comma');
    }

    @at-root
    #{$selectors} {
        @content;
    }
}