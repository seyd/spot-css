/// Sets mode of strictness of evaluating SPOT rules which will be applied on next component.
/// When 'draft' is set then +register and +default mixin is not required.
///
/// @group Component
/// @access public
/// @since from version 2.1.0
/// @param { String } $mode - Allowed values are 'strict' and 'draft'.
/// @throw SPOT CSS: mode/invalid-input - mode mixin accepts only value 'strict' or 'draft'.
/// @output
@mixin mode($mode) {
    $new-mode: mode($mode);
}


/// Sets a new configuration of the SPOT CSS framework.
/// All missing keys in the given $config will be automatically set to default values.
///
/// @group General
/// @access public
/// @param { Map } $config - New configuration (you can rebound from the $_default-spot-config variable).
/// @throw SPOT CSS: spot-config/invalid-input - input has to be a Map type.
/// @output
@mixin spot-config($config) {
    @if type_of($config)!='map' {
        @error $SPOT_ERROR_PREFIX + "spot-config/invalid-input - input has to be a Map type.";
    }
    $_current-spot-config: map-merge($_default-spot-config, $config) !global;
}


/// Sets a value for given key of the current SPOT framework configuration.
///
/// @group General
/// @access public
/// @param { String } $key - A key of the SPOT configuration (see $_default-spot-config variable).
/// @param { any } $value - A value for the given $key.
/// @output
@mixin spot-set($key, $value) {
    $new: ( $key: $value );
    $_current-spot-config: map-merge($_current-spot-config, $new) !global;
}


/// Main top-level mixin to define component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another (with sub-component mixin).
///
/// @group Component
/// @access public
/// @param { String[] } $args... - 1. ($selector),  2. ($alias, $selector), 3. ($selector1, $selector2), 4. ($alias, $selector1, $selector2, $selector3)
/// @content
/// @throw SPOT CSS: component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: component/sub-component - you cannot use mixin component in component. Instead use mixin sub-component and also register it in parent component.
/// @throw SPOT CSS: component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS [component/simple-element-selector] - given selector is a simple element selector ({selector}) but the framework is currently set to not allow such selectors for components. Read more at https://spotcss.io/errors/component/simple-element-selector
/// @throw SPOT CSS: component/already-registered - given selector is already registered as component ({selector}).
/// @output Given selector with given content.
/// @todo component selector must be a simple selector check
@mixin component($args...) {
    $alias: null;  // not used later (yet)
    $first: first($args);
    $selectors: $args;

    @if _is-alias($first) {
        $alias: _normalize-alias(nth($args, 1));
        $selectors: shift($args);
    }

    @if length($selectors)==0 or not first($selectors) or first($selectors)=="" {
        @error $SPOT_ERROR_PREFIX + "component/no-selector - selector was expected but nothing passed.";
    }

    @if component()!='' {
        @error $SPOT_ERROR_PREFIX + "component/sub-component - you cannot use mixin component in component. Instead use mixin sub-component and also register it in parent component.";
    }

    $simple-element-exceptions: spot-get('exceptions-of-simple-element-components');
    @if $simple-element-exceptions=='' {
        $simple-element-exceptions: '[at-least-one-non-existing-exception-selector]';
    }

    // for all selectors (component alternatives)
    @each $selector in $selectors {
        
        $multiple-selectors: selector-parse($selector);
        @if length($multiple-selectors)>1 {
            @error $SPOT_ERROR_PREFIX + "component/single-selector - given selector is not a single selector ('"+$selector+"').";
        }

        $component-selector: selector-parse($selector)+''; // normalize selector (e.g. "ul>li" => "ul > li")

        // if simple element selectors are disallowed (is on and is not in ignored element list)
        @if spot-get('disallow-simple-element-components') and is-standard-html-element($selector) and not selector-unify($selector, $simple-element-exceptions) {
            @error _error('component/simple-element-selector')+" - given selector is a simple element selector ('"+$selector+"') but the framework is currently set to not allow such selectors for components. Read more at https://spotcss.io/errors/component/simple-element-selector";
        }

        // 1)
        // if already registred
        @if index($_registered-components, $component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "component/already-registered - given selector is already registered as component ('"+$component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $component-selector, 'comma') !global;
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, $component-selector, 'space') !global;

        // // create map for used modifiers (nested) per component
        // $_used-modifiers: map-merge($_used-modifiers, (component(): ())) !global;
        // $_current-modifiers-stack: map-merge($_current-modifiers-stack, (component(): [])) !global;

        // @debug '-------------------------------';
        // @debug 'Component: '+component();

        #{$component-selector} {
            @content;
        }
        
        @if $_current-component-mode!='draft' {
            @include _check-if-all-sub-elements-were-used( component() );
            @include _check-if-all-mutations-were-used( component() );
        }
        
        // @debug map-get($_used-modifiers, component());
        // @debug map-get($_current-modifiers-stack, component());

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;

        // reset current mode to default after each component
        $_current-component-mode: $_default-component-mode !global;
    }
}


/// Child-component mixin to define (direct child) sub-component in component (with separate states, variants and sub-elements).
///
/// Context, responsive and browser modifiers are inherited from parent component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another.
///
/// @deprecated from version 2
/// @group Component
/// @access public
/// @deprecated from version 2+, instead use +element() mixin.
/// @param { String } $selector - single selector of sub-component
/// @content
/// @throw SPOT CSS: sub-component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.
/// @throw SPOT CSS: sub-component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('selector').
/// @throw SPOT CSS: sub-component/already-registered - trying to register already registered sub-component 'selector' for component 'component'.
/// @throw SPOT CSS: sub-component/childs-in-register - it is not allowed call any other modifiers and sub element mixins in sub-component in register of component 'component'. Register all those modifiers in register section of sub-component 'selector'.
/// @throw SPOT CSS: sub-component/unknown-unregistered - given sub-component 'selector' is not registered in direct parent component ('component').
/// @throw SPOT CSS: sub-component/duplicate - given selector is already used as sub-component ({selector}).
/// @output Given selector with given content.
@mixin child-component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "child-component/no-selector - selector was expected but nothing passed.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "child-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "child-component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $sub-component-selector: #{ & + ' > ' + $selector };

    // check for separator
    @if not $_is-register-mode and not $_was-used-sub-element-separator and spot-get(force-element-separator) {
        @warn $SPOT_ERROR_PREFIX + "child-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('"+$sub-component-selector+"').";
    }
    $_was-used-sub-element-separator: false !global;
    
    @if $_is-register-mode {
        @include _check-duplicity-of-sub-selectors('child-component', $sub-component-selector, $selector);

         // store current component selector (into stack)
        $_current-components: append($_current-components, '> '+$selector, 'space') !global;

        $_is-child-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-child-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
    @else {
        // check if sub-component is registered
        @if not index($_already-used-selectors, $sub-component-selector) and $_current-component-mode!='draft' {
            @error $SPOT_ERROR_PREFIX + "child-component/unknown-unregistered - given sub-component '"+$selector+"' is not registered in direct parent component ('"+$sub-component-selector+"').";
        }
        // 1)
        // if already registred
        @if index($_registered-components, $sub-component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "child-component/duplicate - given selector is already used as sub-component ('"+$sub-component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
            $_already-used-multiple-selectors: append($_already-used-multiple-selectors, $sub-component-selector, 'comma') !global;
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, '> '+$selector, 'space') !global;

        $_is-child-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-child-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
}

/// Sub-component mixin to define component in component (with separate states, variants and sub-elements).
///
/// Context, responsive and browser modifiers are inherited from parent component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another.
///
/// @deprecated from version 2
/// @group Component
/// @access public
/// @deprecated from version 2+, instead use +element() mixin.
/// @param { String } $selector - single selector of sub-component
/// @content
/// @throw SPOT CSS: sub-component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.
/// @throw SPOT CSS: sub-component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('selector').
/// @throw SPOT CSS: sub-component/already-registered - trying to register already registered sub-component 'selector' for component 'component'.
/// @throw SPOT CSS: sub-component/childs-in-register - it is not allowed call any other modifiers and sub element mixins in sub-component in register of component 'component'. Register all those modifiers in register section of sub-component 'selector'.
/// @throw SPOT CSS: sub-component/unknown-unregistered - given sub-component 'selector' is not registered in direct parent component ('component').
/// @throw SPOT CSS: sub-component/duplicate - given selector is already used as sub-component ({selector}).
/// @output Given selector with given content.
@mixin sub-component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "sub-component/no-selector - selector was expected but nothing passed.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "sub-component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $sub-component-selector: #{ & + ' ' + $selector };

    // check for separator
    @if not $_is-register-mode and not $_was-used-sub-element-separator and spot-get(force-element-separator) {
        @warn $SPOT_ERROR_PREFIX + "sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('"+$sub-component-selector+"').";
    }
    $_was-used-sub-element-separator: false !global;
    
    @if $_is-register-mode { 
        @include _check-duplicity-of-sub-selectors('sub-component', $sub-component-selector, $selector);

        // store current component selector (into stack)
        $_current-components: append($_current-components, ' '+$selector, 'space') !global;

        $_is-sub-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-sub-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
    @else {
        // check if sub-component is registered
        @if not index($_already-used-selectors, $sub-component-selector) and $_current-component-mode!='draft' {
            @error $SPOT_ERROR_PREFIX + "sub-component/unknown-unregistered - given sub-component '"+$selector+"' is not registered in direct parent component ('"+$sub-component-selector+"').";
        }
        // 1)
        // if already registred
        @if index($_registered-components, $sub-component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "sub-component/duplicate - given selector is already used as sub-component ('"+$sub-component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
            $_already-used-multiple-selectors: append($_already-used-multiple-selectors, $sub-component-selector, 'comma') !global;
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, ' '+$selector, 'space') !global;

        $_is-sub-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-sub-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
}


/// Main top-level mixin to define component.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: register/no-component - the mixin register must be used inside a component.
/// @throw SPOT CSS: register/already-called - the mixin register was already called for component 'component'.
/// @output Given selector with given content.
@mixin register {
    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "register/no-component - the mixin register must be used inside a component.";
    }
    
    /// @todo check if was called as first mixin in component
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // run only once per component
    @if _register-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "register/already-called - the mixin register was already called for component '"+component()+"'.";
    }
    @else {
        @include _set_register-mixin-was-already-called();
    }

    $_is-register-mode: true !global;
    @content;
    $_is-register-mode: false !global;
}


/// This mixins defines default component or sub elements style.
/// It is required only when other modifiers are used. 
/// This is not modifier so it has to be not registered in register mixin.
/// This mixin helps only in semantic matter better understanding of component style.
/// If just static style of an element, default mixin is not required.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: default/in-register - the mixin default doesn't have to be registered in register mixin in component 'component'.
/// @throw SPOT CSS: default/already-called - the mixin default was already called for element 'element'.
/// @output Just given content.
@mixin default {
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "default/in-register - the mixin default doesn't have to be registered in register mixin in component '"+component()+"'.";
    }    
    // run only once per component selector
    $current-media-selector: _wrap-into-media-selector(&);
    @if index($_default-called-on, $current-media-selector) {
        @error $SPOT_ERROR_PREFIX + "default/already-called - the mixin default was already called for element '"+$current-media-selector+"'.";
    }
    $_default-called-on: append($_default-called-on, $current-media-selector) !global;
    
    $_is-default-mode: true !global;
    @content;
    $_is-default-mode: false !global;
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register variant in current component.
///
/// 2) when used outside of register mixin, it will apply given variant(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require variant selector (and all values when placeholder '?' is used in variant selector) OR when not in regiter mode selector extension(s) = variant names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given variant(s) with given content.
@mixin variant($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('variant', $args...);
    }
    @else {
        @include _apply-modifier('variant', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>variant</b> but different semantic naming.
/// @see {mixin} variant
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin state($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('state', $args...);
    }
    @else {
        @include _apply-modifier('state', $args...) {        
            @content;
        }
    }   
}


/// Mixin for register and apply internal state of component. 
/// Difference between internal-state and state mixin is that internal-state 
/// is binded to component element or sub-element where is internal-state registered in register mixin.
/// It works as super-state so it is looking to parent elements where internal-state is registered. 
/// @see {mixin} variant
/// @group Component
/// @access public
/// @param { String } $args... Same as for state mixin.
/// @content
/// @output It will output selector extended by given internal-state(s) with given content.
@mixin internal-state($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('internal-state', $args...);
    }
    @else {
        @include _apply-modifier('internal-state', $args...) {        
            @content;
        }
    }   
}


/// Extend current selector by super component state.
///
/// It is appling the nearest super component with given state selector.
///
/// If first argument is an number, it is the index of supper component (positive number means from top 1, negative from nearest super element -1).
///
/// @group Component
/// @access public
/// @deprecated from version 2+, use just +state('identifier',-1) or other negative index.
/// @param { String } $args... - selector extension(s) = state names
/// @content
/// @throw See errors of mixin _super-modifier and _apply-modifier.
/// @output It will output selector extended by given super component state(s) with given content.
@mixin super-state($args...) {
    @include _super-modifier('super-state', $args...) {
        @content;
    }
}


/// Extend current selector by super component variant.
///
/// It is appling the nearest super component with given variant selector.
///
/// If first argument is an number, it is the index of supper component (positive number means from top 1, negative from nearest super element -1).
///
/// @group Component
/// @access public
/// @deprecated from version 2+, use just +variant('identifier',-1) or other negative index.
/// @param { String } $args... - selector extension(s) = variant names
/// @content
/// @throw See errors of mixin _super-modifier and _apply-modifier.
/// @output It will output selector extended by given super component variant(s) with given content.
@mixin super-variant($args...) {
    @include _super-modifier('super-variant', $args...) {
        @content;
    }
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register context in current component.
///
/// 2) when used outside of register mixin, it will apply given context(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require context selector and optional alias OR when not in regiter mode selector extension(s) = context names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given context(s) with given content.
/// @throw SPOT CSS: context/no-global-found - you entered only alias of context mutation '{alias}'. No global context found with this alias or maybe you wanted provide second argument with context selector.
@mixin context($args...) {
    @if $_is-register-mode {
        // if only alias is given (one argument), check if it's registered with `global-responsive` mixin
        @if length($args)==1 and _is-alias(first($args)) {
            $alias: _normalize-alias(first($args));
         
            $already-registered-alias: map-get($_registered-global-contexts, $alias);
            @if not $already-registered-alias {
                @error $SPOT_ERROR_PREFIX + "context/no-global-found - you entered only alias of context mutation '"+first($args)+"'. No global context found with this alias or maybe you wanted provide second argument with context selector.";
            }

            $args: append($args, $already-registered-alias);
        }

        // ' &' appendix signalize different mode of composing selector
        @include _register-modifiers('context &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of composing selector
        @include _apply-modifier('context &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>context</b> but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
/// @throw SPOT CSS: browser/no-global-found - you entered only alias of browser mutation '{alias}'. No global browser found with this alias or maybe you wanted provide second argument with context selector.
@mixin browser($args...) {
    @if $_is-register-mode {
        // if only alias is given (one argument), check if it's registered with `global-responsive` mixin
        @if length($args)==1 and _is-alias(first($args)) {
            $alias: _normalize-alias(first($args));
         
            $already-registered-alias: map-get($_registered-global-browsers, $alias);
            @if not $already-registered-alias {
                @error $SPOT_ERROR_PREFIX + "browser/no-global-found - you entered only alias of browser mutation '"+first($args)+"'. No global browser found with this alias or maybe you wanted provide second argument with context selector.";
            }

            $args: append($args, $already-registered-alias);
        }

        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('browser &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('browser &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>context</b> but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
/// @throw SPOT CSS: responsive/no-global-found - you entered only alias of responsive mutation '{alias}'. No global responsive found with this alias or maybe you wanted provide second argument with media query.
@mixin responsive($args...) {
    @if $_is-register-mode {
        // if only alias is given (one argument), check if it's registered with `global-responsive` mixin
        @if length($args)==1 and _is-alias(first($args)) {
            $alias: _normalize-alias(first($args));
         
            $already-registered-alias: map-get($_registered-global-responsives, $alias);
            @if not $already-registered-alias {
                @error $SPOT_ERROR_PREFIX + "responsive/no-global-found - you entered only alias of responsive mutation '"+first($args)+"'. No global responsive found with this alias or maybe you wanted provide second argument with media query.";
            }

            $args: append($args, $already-registered-alias);
        }

        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('responsive &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('responsive &', $args...) {        
            @content;
        }
    }   
}


/// Element mixin to define sub elements in component.
///
/// Context, responsive and browser modifiers are inherited from parent component but element can register also its own.
///
/// 1) It checks if same element is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Elements can be nested one into another.
///
/// @group Component
/// @access public
/// @since from version 2.0.0
/// @param { String } $selector - single selector of sub element of component. It has to be single and simple selector.
/// @content
/// @throw SPOT CSS: element/no-selectors - at least one selector is expected.
/// @throw SPOT CSS: element/no-component - you cannot use mixin element outside of component.
/// @throw SPOT CSS: element/in-modifier - it is not allowed to use element in modifier '{current_modifier}'.
/// @throw SPOT CSS: element/in-default - it is not allowed to call element mixin in default mixin (in component '{component}).
/// @throw SPOT CSS: element/missing-separator - there is sub-element separator mixin (_______) missing before element mixin (in component '{component}').
/// @throw SPOT CSS: element/already-registered - trying to register already registered element '{selector}' for component '{component}'.
/// @throw SPOT CSS: element/unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @throw SPOT CSS: element/duplicate - given element selector is already used in current block ('{selector}').";
/// @throw SPOT CSS: element/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: element/single-selector - given selector is not a single selector, because contains comma(s): '{selector}'.
/// @throw SPOT CSS: element/simple-selector - given selector has to be simple selector withou spaces, '>' and '~' but is: '{selector}'.
/// @throw SPOT CSS: element-alias/not-first-argument - You can use alias only as a firt argument only. But you are using argument with alias '{alias}' for component selector '{selector}' wrong.
/// @throw SPOT CSS: element-alias/already-registered - trying to register already registered sub-element '{alias}' for component selector '{selector}'.
/// @throw SPOT CSS: element-alias/unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @output Given selector with given content.
@mixin element($selectors...) {
    @if length($selectors)==0 {
        @error $SPOT_ERROR_PREFIX + "element/no-selectors - at least one selector is expected.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "element/no-component - you cannot use mixin element outside of component.";
    }

    // do not allow in modifier
    @if $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "element/in-modifier - it is not allowed to use element in modifier '"+$_current_modifier+"'.";
    }

    // do not allow in default mutation
    @if $_is-default-mode {
        @error $SPOT_ERROR_PREFIX + "element/in-default - it is not allowed to call element mixin in default mixin (in component '"+component()+"').";
    }

    // check for separator ____________________________
    @if not $_is-register-mode and not $_was-used-sub-element-separator and spot-get(force-element-separator) {
        @warn $SPOT_ERROR_PREFIX + "element/missing-separator - there is sub-element separator mixin (_______) missing before element mixin in component ('"+component()+"').";
    }
    // reset flag for next (sub)element
    $_was-used-sub-element-separator: false !global;

    // test for not empty and single selector
    @each $selector in $selectors {
        @if not $selector or $selector=="" {
            @error $SPOT_ERROR_PREFIX + "element/no-selector - selector was expected but nothing passed.";
        }
        @if not _is-alias($selector) {
            $parts: selector-parse($selector);
            @if length($parts) > 1 {
                @error $SPOT_ERROR_PREFIX + "element/single-selector - given selector is not a single selector, because contains comma(s): '"+$selector+"'.";
            }

            @if length-of-simple-selector(selector-trim-combinators($selector)) > 1 {            
                @error $SPOT_ERROR_PREFIX + "element/simple-selector - given selector has to be simple selector withou spaces, '>' and '~' but is: '"+$selector+"'.";
            }
        }
    }
    
    @if $_is-register-mode { 
        $counter: 0;
        $selectors-without-alias: shift($selectors); // remove first item (alias)
        
        $alias: null;
        $component-alias-key: null;
        $registered-component-alias: null;

        @each $selector in $selectors {            
            $counter: $counter + 1;

            @if _is-alias($selector) {
                @if $counter>1 {
                    // @TODO test
                    @error $SPOT_ERROR_PREFIX + "element-alias/not-first-argument - You can use alias only as a firt argument only. But you are using argument with alias '"+$alias+"' for component selector '"+&+"' wrong.";
                }
                
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                $registered-component-element-alias: map-get($_registered-component-element-aliases, $component-alias-key);
                
                // guarding duplicity of sub-elements alias (for whole component)
                @if $registered-component-alias and (($registered-component-element-alias and str-index(&+'', $registered-component-element-alias+'')==1) or $registered-component-alias!=$selectors-without-alias) {
                    @error $SPOT_ERROR_PREFIX + "element-alias/already-registered - trying to register already registered sub-element '"+$alias+"' for component selector '"+&+"'.";
                }
                
                $registered-component-alias: $selectors-without-alias;
                $_registered-component-aliases: map-merge($_registered-component-aliases, ($component-alias-key: $registered-component-alias)) !global;
                $_registered-component-element-aliases: map-merge($_registered-component-element-aliases, ($component-alias-key: &)) !global;
            }
            @else {
                // if not alias
                $selector: selector-parse($selector)+''; // normalize selector (e.g. ">li" => "> li")
                $sub-component-selector: #{ & + ' ' + str-trim($selector) };
                
                @include _check-duplicity-of-sub-selectors('element', $sub-component-selector, $selector);

                // store current component selector (into stack)
                $_current-components: append($_current-components, $selector, 'space') !global;

                $_is-child-component-mode: true !global;

                @at-root
                #{$sub-component-selector} {
                    @content;
                }

                $_is-child-component-mode: false !global;

                // remove current component selector (from stack)
                $_current-components: pop($_current-components) !global;
            }
        }        
    }
    @else {
        // store appling sub element in current selector to avoid calling state, variant, etc. after element section (see error "/invalid-order")
        @if not index($_selectors-with-sub-elements, &) {
            $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
        }

        // expand aliases to selectors
        @for $i from 1 through length($selectors) {
            $selector: nth($selectors, $i);
            @if _is-alias($selector) {
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                
                @if not $registered-component-alias {
                    @error $SPOT_ERROR_PREFIX + "element-alias/unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
                }

                $selectors: replace-nth($selectors, $i, $registered-component-alias);
            }
        }

        @each $selector in $selectors {
            $selector: selector-parse($selector)+''; // normalize selector (e.g. ">li" => "> li")
            $sub-component-selector: #{ & + ' ' + str-trim($selector) };
            // check if element is registered
            @if not index($_already-used-selectors, $sub-component-selector) and $_current-component-mode!='draft' {
                @error $SPOT_ERROR_PREFIX + "element/unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
            }
            // 1)
            // if already registred
            @if index($_registered-components, $sub-component-selector)!=null {
                @error $SPOT_ERROR_PREFIX + "element/duplicate - given element selector is already used in current block ('"+$sub-component-selector+"').";
            }
            @else {
                // store component selector if is not stored yet
                $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
                $_already-used-multiple-selectors: append($_already-used-multiple-selectors, $sub-component-selector, 'comma') !global;
            }

            // 2)
            // store current component selector (into stack)
            $_current-components: append($_current-components, $selector, 'space') !global;

            $_is-child-component-mode: true !global;

            @at-root
            #{$sub-component-selector} {
                @content;
            }

            $_is-child-component-mode: false !global;

            // remove current component selector (from stack)
            $_current-components: pop($_current-components) !global;
        }
    }
}


/// Declares direct child block in current component selector.
/// @group Component
/// @access public
/// @deprecated from version 2+, instead use +element() mixin.
/// @param { String } $selectors... - One or more selectors of direct childs. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: child-element/no-selectors - at least one child selector is expected.
/// @throw SPOT CSS: child-element/in-modifier - it is not allowed to use child-element in modifier 'modifier'.
/// @throw SPOT CSS: child-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: child-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: child-element/multilevel-selector - given selector is not a single selector ('selector'). Just use more child-element mixins nested.
/// @throw SPOT CSS: child-element/already-used - the child-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every child-element.
/// @output Given selector with given content.
@mixin child-element($selectors...) {
    @include _sub-element('child', $selectors...) {
        @content;
    }
}


/// Declares any other then child block in current component selector. 
/// It is same as child-element mixin, but it does not force direct child selector (>) and
/// it could contain multilevel selectors also (e.g. 'div a.disabled span').
/// Note: It is strongly recomended to use <b>child-element</b> mixin everytime it is possible!
/// @group Component
/// @access public
/// @deprecated from version 2+, instead use +element() mixin.
/// @param { String } $selectors... - One or more selectors. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: sub-element/no-selectors - at least one selector is expected.
/// @throw SPOT CSS: sub-element/in-modifier - it is not allowed to use sub-element in modifier 'modifier'.
/// @throw SPOT CSS: sub-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: sub-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: sub-element/already-used - the sub-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every sub-element.
/// @output Given selector with given content.
@mixin sub-element($selectors...) {
    @include _sub-element('sub', $selectors...) {
        @content;
    }
}


/// Declares pseudo element(s) of current component selector.
/// @group Component
/// @access public
/// @param { String } $selectors - pseudo selector 'before', 'after', 'first-letter', 'first-line', 'placeholder' or 'selection' (also prefixes ':' and ':: are accepted)
/// @content
/// @throw SPOT CSS: pseudo-element/no-selectors - at least one pseudo selector is expected.
/// @throw SPOT CSS: pseudo-element/in-modifier - it is not allowed to use pseudo-element in modifier 'modifier'.
/// @throw SPOT CSS: pseudo-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: pseudo-element/invalid-selector - Invalid value for pseudo element 'selector'. Only valid values are 'before', 'after' and other pseudo elements.
/// @throw SPOT CSS: pseudo-element/already-used - the pseudo-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every pseudo-element.
/// @output Given selector with given content.
@mixin pseudo-element($selectors...) {
    @include _sub-element('pseudo', $selectors...) {
        @content;
    }
}


/// Add selector specificity at all levels at once.
/// @access public
/// @param { Number } $id-spec - How many levels to add at id level (1..n)
/// @param { Number } $cl-spec - How many levels to add at class level (1..n)
/// @param { Number } $el-spec - How many levels to add at element level (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-specificity($id-spec: 0, $cl-spec: 0, $el-spec: 0) {
    @at-root #{add-specificity(&, $id-spec, $cl-spec, $el-spec)} {
        @content;
    }
}


/// Add selector specificity at element level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-element-specificity($n) {
    @at-root #{add-element-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at class level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-class-specificity($n) {
    @at-root #{add-class-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at id level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-id-specificity($n) {
    @at-root #{add-id-specificity(&, $n)} {
        @content;
    }
}


/// Outputs specificity in your CSS as (invalid) properties.
/// Please, don't use this mixin in production.
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access public
/// @output specificity (map as string), specificity-value (specificity value as integer)
@mixin specificity() {
    specificity: specificity(&);
    specificity-value: specificity(&, true);
}


/// Override current selector over given selector.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin override($args...) {
    @at-root #{override(&, $args...)} {
        @content;
    }
}


/// Filter given selector with given sub-selectors.
/// Every selector which does not contain any of given args will be excluded.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @throw SPOT CSS: only-for/in-register - the mixin default doesn't have to be registered in register mixin in component 'component'.
/// @throw SPOT CSS: only-for/default-is-missing - the only-for '$args' in component 'component' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).
/// @output Filtered selector(s) with given inner content.
@mixin only-for($args...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "only-for/in-register - the mixin only-for doesn't have to be registered in register mixin in component '"+component()+"'.";
    }
    // force using 'default' mixin when using modifiers
    @if not _default-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "only-for/default-is-missing - the only-for '"+inspect($args)+"' in component '"+component()+"' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).";
    }

    @at-root #{only-for(&, $args...)} {
        @content;
    }
}


/// Register global reusable context mutation addresable with alias.
/// You can use it via alias in component register section.
/// (we recommend to use it in global variables section/file)
///
/// @group Global
/// @access public
/// @param { String } $alias - Unique alias of registered context mutation, e.g. "{mobile}" (must be enclosed in curly brackets).
/// @param { String } $selectorOrMediaQuery - Context selector or media query.
/// @throw SPOT CSS: global-context/bad-alias - alias must be enclosed in curly brackets.
/// @throw SPOT CSS: global-context/no-alias - alias must contain at least one character.
/// @throw SPOT CSS: global-context/duplicate-alias - alias '{alias}' is already registered as a global alias.
@mixin global-context($alias, $selectorOrMediaQuery) {
    $alias: _normalize-alias($alias);

    @if _is-alias($alias)==false {
        @error $SPOT_ERROR_PREFIX + "global-context/bad-alias - alias must be enclosed in curly brackets.";
    }
    
    @if str-length(str-replace($alias, ' ', ''))<=2 {
        @error $SPOT_ERROR_PREFIX + "global-context/no-alias - alias must contain at least one character.";
    }
    
    $already-registered-alias: map-get($_registered-global-contexts, $alias);
    @if $already-registered-alias {
        @error $SPOT_ERROR_PREFIX + "global-context/duplicate-alias - alias '"+$alias+"' is already registered as a global alias.";
    }

    $_registered-global-contexts: map-merge($_registered-global-contexts, ($alias: $selectorOrMediaQuery)) !global;
}


/// Register global reusable responsive mutation addresable with alias.
/// You can use it via alias in component register section.
/// (we recommend to use it in global variables section/file)
///
/// @group Global
/// @access public
/// @param { String } $alias - Unique alias of registered responsive mutation, e.g. "{mobile}" (must be enclosed in curly brackets).
/// @param { String } $selectorOrMediaQuery - Context selector or media query.
/// @throw SPOT CSS: global-responsive/bad-alias - alias must be enclosed in curly brackets.
/// @throw SPOT CSS: global-responsive/no-alias - alias must contain at least one character.
/// @throw SPOT CSS: global-responsive/duplicate-alias - alias '{alias}' is already registered as a global alias.
@mixin global-responsive($alias, $selectorOrMediaQuery) {
    $alias: _normalize-alias($alias);

    @if _is-alias($alias)==false {
        @error $SPOT_ERROR_PREFIX + "global-responsive/bad-alias - alias must be enclosed in curly brackets.";
    }
    
    @if str-length(str-replace($alias, ' ', ''))<=2 {
        @error $SPOT_ERROR_PREFIX + "global-responsive/no-alias - alias must contain at least one character.";
    }
    
    $already-registered-alias: map-get($_registered-global-responsives, $alias);
    @if $already-registered-alias {
        @error $SPOT_ERROR_PREFIX + "global-responsive/duplicate-alias - alias '"+$alias+"' is already registered as a global alias.";
    }

    $_registered-global-responsives: map-merge($_registered-global-responsives, ($alias: $selectorOrMediaQuery)) !global;
}


/// Register global reusable browser mutation addresable with alias.
/// You can use it via alias in component register section.
/// (we recommend to use it in global variables section/file)
///
/// @group Global
/// @access public
/// @param { String } $alias - Unique alias of registered browser mutation, e.g. "{mobile}" (must be enclosed in curly brackets).
/// @param { String } $selectorOrMediaQuery - Context selector or media query.
/// @throw SPOT CSS: global-browser/bad-alias - alias must be enclosed in curly brackets.
/// @throw SPOT CSS: global-browser/no-alias - alias must contain at least one character.
/// @throw SPOT CSS: global-browser/duplicate-alias - alias '{alias}' is already registered as a global alias.
@mixin global-browser($alias, $selectorOrMediaQuery) {
    $alias: _normalize-alias($alias);

    @if _is-alias($alias)==false {
        @error $SPOT_ERROR_PREFIX + "global-browser/bad-alias - alias must be enclosed in curly brackets.";
    }
    
    @if str-length(str-replace($alias, ' ', ''))<=2 {
        @error $SPOT_ERROR_PREFIX + "global-browser/no-alias - alias must contain at least one character.";
    }
    
    $already-registered-alias: map-get($_registered-global-browsers, $alias);
    @if $already-registered-alias {
        @error $SPOT_ERROR_PREFIX + "global-browser/duplicate-alias - alias '"+$alias+"' is already registered as a global alias.";
    }

    $_registered-global-browsers: map-merge($_registered-global-browsers, ($alias: $selectorOrMediaQuery)) !global;
}


// @deprecated
@mixin already-defined-in($modifiers...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/in-register - the mixin already-defined-in doesn't have to be registered in register mixin in component '"+component()+"'.";
    }

    // do not allow outside of modifier(s)
    @if not $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/outside-modifiers - it is not allowed to use already-defined-in mixin outside of modifiers.";
    }
    // at least 2 nested modifiers
    $current-modifier-stack: map-get($_current-modifiers-stack, component()); // for this component
    @if length($current-modifier-stack) < 2 {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/at-least-2-modifiers - it is not allowed to use already-defined-in mixin only in single level modifier.";
    }
    // add 'already-defined-in' property into current modifier to the stack
    $current-modifier-stack: map-get($_current-modifiers-stack, component()); // for this component
    $modifier-pointer: map-get($_used-modifiers, component());
    $len: length($current-modifier-stack);
    $parents: []; 
    @each $modifier in $current-modifier-stack {
        $parents: append($parents, $modifier-pointer, 'comma');
        $modifier-pointer: map-get($modifier-pointer, $modifier);
    }
    $map: ('already-defined-in': $modifiers);
    @while length($parents)>0 {
        $i: length($parents);
        $name: nth($current-modifier-stack, $i);
        $last: nth($parents, $i);
        $map: map-merge($last, ($name: $map));
        $parents: nth-delete($parents, -1);
    }
    $_used-modifiers: map-merge($_used-modifiers, (component(): $map)) !global;
}


// Extends selector in the actual selector path
// ($something: '.item', $extenssion: '':first-child, :last-child') => $new-extension: 'item:first-child, item:last-child'
@mixin extend($something, $extension) {
    @at-root #{extend(&, $something, $extension)} {
        @content;
    }
}


/// Mandatory separator before each sub-element modifier. Use as long as you wish.
@mixin _ { @include _sub-element-separator; }
@mixin __ { @include _sub-element-separator; }
@mixin ___ { @include _sub-element-separator; }
@mixin ____ { @include _sub-element-separator; }
@mixin _____ { @include _sub-element-separator; }
@mixin ______ { @include _sub-element-separator; }
@mixin _______ { @include _sub-element-separator; }
@mixin ________ { @include _sub-element-separator; }
@mixin _________ { @include _sub-element-separator; }
@mixin __________ { @include _sub-element-separator; }
@mixin ___________ { @include _sub-element-separator; }
@mixin ____________ { @include _sub-element-separator; }
@mixin _____________ { @include _sub-element-separator; }
@mixin ______________ { @include _sub-element-separator; }
@mixin _______________ { @include _sub-element-separator; }
@mixin ________________ { @include _sub-element-separator; }
@mixin _________________ { @include _sub-element-separator; }
@mixin __________________ { @include _sub-element-separator; }
@mixin ___________________ { @include _sub-element-separator; }
@mixin ____________________ { @include _sub-element-separator; }
@mixin _____________________ { @include _sub-element-separator; }
@mixin ______________________ { @include _sub-element-separator; }
@mixin _______________________ { @include _sub-element-separator; }
@mixin ________________________ { @include _sub-element-separator; }
@mixin _________________________ { @include _sub-element-separator; }
@mixin __________________________ { @include _sub-element-separator; }
@mixin ___________________________ { @include _sub-element-separator; }
@mixin ____________________________ { @include _sub-element-separator; }
@mixin _____________________________ { @include _sub-element-separator; }
@mixin ______________________________ { @include _sub-element-separator; }
@mixin _______________________________ { @include _sub-element-separator; }
@mixin ________________________________ { @include _sub-element-separator; }
@mixin _________________________________ { @include _sub-element-separator; }
@mixin __________________________________ { @include _sub-element-separator; }
@mixin ___________________________________ { @include _sub-element-separator; }
@mixin ____________________________________ { @include _sub-element-separator; }
@mixin _____________________________________ { @include _sub-element-separator; }
@mixin ______________________________________ { @include _sub-element-separator; }
@mixin _______________________________________ { @include _sub-element-separator; }
@mixin ________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________________________ { @include _sub-element-separator; }