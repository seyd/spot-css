/// Sets mode of strictness of evaluating SPOT rules which will be applied on next component.
/// When 'draft' is set then +register and +default mixin is not required.
///
/// @group Component
/// @access public
/// @since from version 2.1.0
/// @param { String } $mode - Allowed values are 'strict' and 'draft'.
/// @throw SPOT CSS: mode/invalid-input - mode mixin accepts only value 'strict' or 'draft'.
/// @output
@mixin mode($mode) {
    $new-mode: mode($mode);
}


/// Sets a new configuration of the SPOT CSS framework.
/// All missing keys in the given $config will be automatically set to default values.
///
/// @group General
/// @access public
/// @param { Map } $config - New configuration (you can rebound from the $_default-spot-config variable).
/// @throw SPOT CSS: spot-config/invalid-input - input has to be a Map type.
/// @output
@mixin spot-config($config) {
    @if type_of($config)!='map' {
        @error $SPOT_ERROR_PREFIX + "spot-config/invalid-input - input has to be a Map type.";
    }
    $_current-spot-config: map-merge($_default-spot-config, $config) !global;
}


/// Sets a value for given key of the current SPOT framework configuration.
///
/// @group General
/// @access public
/// @param { String } $key - A key of the SPOT configuration (see $_default-spot-config variable).
/// @param { any } $value - A value for the given $key.
/// @output
@mixin spot-set($key, $value) {
    $new: ( $key: $value );
    $_current-spot-config: map-merge($_current-spot-config, $new) !global;
}


/// Main top-level mixin to define component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another (with sub-component mixin).
///
/// @group Component
/// @access public
/// @param { String[] } $args... - 1. ($selector),  2. ($alias, $selector), 3. ($selector1, $selector2), 4. ($alias, $selector1, $selector2, $selector3)
/// @content
/// @throw SPOT CSS: component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: component/sub-component - you cannot use mixin component in component. Instead use mixin sub-component and also register it in parent component.
/// @throw SPOT CSS: component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS [component/simple-element-selector] - given selector is a simple element selector ({selector}) but the framework is currently set to not allow such selectors for components. Read more at https://spotcss.io/errors/component/simple-element-selector
/// @throw SPOT CSS: component/already-registered - given selector is already registered as component ({selector}).
/// @output Given selector with given content.
/// @todo component selector must be a simple selector check
@mixin component($args...) {
    $alias: null;  // not used later (yet)
    $first: first($args);
    $selectors: $args;

    @if _is-alias($first) {
        $alias: _normalize-alias(nth($args, 1));
        $selectors: shift($args);
    }

    @if length($selectors)==0 or not first($selectors) or first($selectors)=="" {
        @error $SPOT_ERROR_PREFIX + "component/no-selector - selector was expected but nothing passed.";
    }

    @if component()!='' {
        @error $SPOT_ERROR_PREFIX + "component/sub-component - you cannot use mixin component in component. Instead use mixin sub-component and also register it in parent component.";
    }

    $simple-element-exceptions: spot-get('exceptions-of-simple-element-components');
    @if $simple-element-exceptions=='' {
        $simple-element-exceptions: '[at-least-one-non-existing-exception-selector]';
    }

    @if length($selectors)>1 {
        $_current-component-selectors-for-only-for: #{join-list-to-string($selectors, ', ')} !global;
    }

    // for all selectors (component alternatives)
    @each $selector in $selectors {
        
        $multiple-selectors: selector-parse($selector);
        @if length($multiple-selectors)>1 {
            @error $SPOT_ERROR_PREFIX + "component/single-selector - given selector is not a single selector ('"+$selector+"').";
        }

        $component-selector: selector-parse($selector)+''; // normalize selector (e.g. "ul>li" => "ul > li")

        // if simple element selectors are disallowed (is on and is not in ignored element list)
        @if spot-get('disallow-simple-element-components') and is-standard-html-element($selector) and not selector-unify($selector, $simple-element-exceptions) {
            @error _error('component/simple-element-selector')+" - given selector is a simple element selector ('"+$selector+"') but the framework is currently set to not allow such selectors for components. Read more at https://spotcss.io/errors/component/simple-element-selector";
        }

        // 1)
        // if already registred
        @if index($_registered-components, $component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "component/already-registered - given selector is already registered as component ('"+$component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $component-selector, 'comma') !global;
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, $component-selector, 'space') !global;

        // // create map for used modifiers (nested) per component
        // $_used-modifiers: map-merge($_used-modifiers, (component(): ())) !global;
        // $_current-modifiers-stack: map-merge($_current-modifiers-stack, (component(): [])) !global;

        // @debug '-------------------------------';
        // @debug 'Component: '+component();

        #{$component-selector} {
            @content;
        }
        
        @if $_current-component-mode!='draft' {
            @include _check-if-all-sub-elements-were-used( component() );
            @include _check-if-all-mutations-were-used( component() );
        }
        
        // @debug map-get($_used-modifiers, component());
        // @debug map-get($_current-modifiers-stack, component());

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;

        // reset current mode to default after each component
        $_current-component-mode: $_default-component-mode !global;
    }

    // unset
    @if $_current-component-selectors-for-only-for!='' {
        $_current-component-selectors-for-only-for: '' !global;
    }

    // check for useless +_________ separator at the end of component
    @if $_was-used-sub-element-separator==true {
        @warn $SPOT_ERROR_PREFIX + "component/unexpected-separator - separator mixin (_______) was used but no element mixin come after it (in component "+inspect($args)+"). But it should be used only before element mixins to bound the element code (before mixin +element, +pseudo-element and +spot-exception-element).";
    }

    @if length($_component_messages)>0 {
        @include _print_messages();   
    }
}


/// Child-component mixin to define (direct child) sub-component in component (with separate states, variants and sub-elements).
///
/// Context, responsive and browser modifiers are inherited from parent component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another.
///
/// @deprecated from version 2
/// @group Component
/// @access public
/// @deprecated from version 2+, instead use +element() mixin.
/// @param { String } $selector - single selector of sub-component
/// @content
/// @throw SPOT CSS: sub-component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.
/// @throw SPOT CSS: sub-component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('selector').
/// @throw SPOT CSS: sub-component/already-registered - trying to register already registered sub-component 'selector' for component 'component'.
/// @throw SPOT CSS: sub-component/childs-in-register - it is not allowed call any other modifiers and sub element mixins in sub-component in register of component 'component'. Register all those modifiers in register section of sub-component 'selector'.
/// @throw SPOT CSS: sub-component/unknown-unregistered - given sub-component 'selector' is not registered in direct parent component ('component').
/// @throw SPOT CSS: sub-component/duplicate - given selector is already used as sub-component ({selector}).
/// @output Given selector with given content.
@mixin child-component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "child-component/no-selector - selector was expected but nothing passed.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "child-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "child-component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $sub-component-selector: #{ & + ' > ' + $selector };

    // check for separator
    @if not $_is-register-mode and not $_was-used-sub-element-separator and spot-get(force-element-separator) {
        @warn $SPOT_ERROR_PREFIX + "child-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('"+$sub-component-selector+"').";
    }
    $_was-used-sub-element-separator: false !global;
    
    @if $_is-register-mode {
        @include _check-duplicity-of-sub-selectors('child-component', $sub-component-selector, $selector);

         // store current component selector (into stack)
        $_current-components: append($_current-components, '> '+$selector, 'space') !global;

        $_is-child-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-child-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
    @else {
        // check if sub-component is registered
        @if not _is-already-used-selectors($sub-component-selector) and $_current-component-mode!='draft' {
            @error $SPOT_ERROR_PREFIX + "child-component/unknown-unregistered - given sub-component '"+$selector+"' is not registered in direct parent component ('"+$sub-component-selector+"').";
        }
        // 1)
        // if already registred
        @if index($_registered-components, $sub-component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "child-component/duplicate - given selector is already used as sub-component ('"+$sub-component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
            @include _register-already-used-multiple-selectors($sub-component-selector);
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, '> '+$selector, 'space') !global;

        $_is-child-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-child-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
}

/// Sub-component mixin to define component in component (with separate states, variants and sub-elements).
///
/// Context, responsive and browser modifiers are inherited from parent component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another.
///
/// @deprecated from version 2
/// @group Component
/// @access public
/// @deprecated from version 2+, instead use +element() mixin.
/// @param { String } $selector - single selector of sub-component
/// @content
/// @throw SPOT CSS: sub-component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.
/// @throw SPOT CSS: sub-component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('selector').
/// @throw SPOT CSS: sub-component/already-registered - trying to register already registered sub-component 'selector' for component 'component'.
/// @throw SPOT CSS: sub-component/childs-in-register - it is not allowed call any other modifiers and sub element mixins in sub-component in register of component 'component'. Register all those modifiers in register section of sub-component 'selector'.
/// @throw SPOT CSS: sub-component/unknown-unregistered - given sub-component 'selector' is not registered in direct parent component ('component').
/// @throw SPOT CSS: sub-component/duplicate - given selector is already used as sub-component ({selector}).
/// @output Given selector with given content.
@mixin sub-component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "sub-component/no-selector - selector was expected but nothing passed.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "sub-component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $sub-component-selector: #{ & + ' ' + $selector };

    // check for separator
    @if not $_is-register-mode and not $_was-used-sub-element-separator and spot-get(force-element-separator) {
        @warn $SPOT_ERROR_PREFIX + "sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('"+$sub-component-selector+"').";
    }
    $_was-used-sub-element-separator: false !global;
    
    @if $_is-register-mode { 
        @include _check-duplicity-of-sub-selectors('sub-component', $sub-component-selector, $selector);

        // store current component selector (into stack)
        $_current-components: append($_current-components, ' '+$selector, 'space') !global;

        $_is-sub-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-sub-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
    @else {
        // check if sub-component is registered
        @if not _is-already-used-selectors($sub-component-selector) and $_current-component-mode!='draft' {
            @error $SPOT_ERROR_PREFIX + "sub-component/unknown-unregistered - given sub-component '"+$selector+"' is not registered in direct parent component ('"+$sub-component-selector+"').";
        }
        // 1)
        // if already registred
        @if index($_registered-components, $sub-component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "sub-component/duplicate - given selector is already used as sub-component ('"+$sub-component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
            @include _register-already-used-multiple-selectors($sub-component-selector);
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, ' '+$selector, 'space') !global;

        $_is-sub-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-sub-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
}


/// Main top-level mixin to define component.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: register/no-component - the mixin register must be used inside a component.
/// @throw SPOT CSS: register/already-called - the mixin register was already called for component 'component'.
/// @output Given selector with given content.
@mixin register {
    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "register/no-component - the mixin register must be used inside a component.";
    }
    
    /// @todo check if was called as first mixin in component
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // run only once per component
    @if _register-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "register/already-called - the mixin register was already called for component '"+component()+"'.";
    }
    @else {
        @include _set_register-mixin-was-already-called();
    }

    $_is-register-mode: true !global;
    @content;
    $_is-register-mode: false !global;
}


/// This mixins defines default component or sub elements style.
/// It is required only when other modifiers are used. 
/// This is not modifier so it has to be not registered in register mixin.
/// This mixin helps only in semantic matter better understanding of component style.
/// If just static style of an element, default mixin is not required.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: default/in-register - the mixin default doesn't have to be registered in register mixin in component 'component'.
/// @throw SPOT CSS: default/already-called - the mixin default was already called for element 'element'.
/// @output Just given content.
@mixin default {
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "default/in-register - the mixin default doesn't have to be registered in register mixin in component '"+component()+"'.";
    }
    
    // because separator was used wrong check for separator ____________________________ (SHOULD NOT BE USED before mutations and default)
    @if $_was-used-sub-element-separator {
        @warn $SPOT_ERROR_PREFIX + "default/unexpected-separator - separator mixin (_______) was used before the +default mixin in component ('"+component()+"'). But it should be used only before element mixins to bound the element code (before mixin +element, +pseudo-element and +spot-exception-element).";
        $_was-used-sub-element-separator: false !global;
    }

    // run only once per component selector
    $current-media-selector: _wrap-into-media-selector(_wrap-into-container-selector(&));
    @if _is-already-registered-default-called-on($current-media-selector) and $_is-in-only-for-block==false {
        @error $SPOT_ERROR_PREFIX + "default/already-called - the mixin default was already called for element '"+$current-media-selector+"'.";
    }
    @include _register-default-called-on($current-media-selector);
    
    $_is-default-mode: true !global;
    @content;
    $_is-default-mode: false !global;
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register variant in current component.
///
/// 2) when used outside of register mixin, it will apply given variant(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require variant selector (and all values when placeholder '?' is used in variant selector) OR when not in regiter mode selector extension(s) = variant names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given variant(s) with given content.
@mixin variant($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('variant', $args...);
    }
    @else {
        @include _apply-modifier('variant', $args...) {
            @content;
        }
    }   
}

/// Alias for mixin variant. Just to point out a variant is beaking the SPOT CSS rules.
/// For example variant is using a component selector of other component, e.g. +spot-exception-variant('.ui-button')
@mixin spot-exception-variant($args...) {
    @include variant($args...) {
        @content;
    }
}


/// Same as mixin <b>variant</b> but different semantic naming.
/// @see {mixin} variant
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin state($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('state', $args...);
    }
    @else {
        @include _apply-modifier('state', $args...) {        
            @content;
        }
    }   
}


/// Mixin for register and apply internal state of component. 
/// Difference between internal-state and state mixin is that internal-state 
/// is binded to component element or sub-element where is internal-state registered in register mixin.
/// It works as super-state so it is looking to parent elements where internal-state is registered. 
/// @see {mixin} variant
/// @group Component
/// @access public
/// @param { String } $args... Same as for state mixin.
/// @content
/// @output It will output selector extended by given internal-state(s) with given content.
@mixin internal-state($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('internal-state', $args...);
    }
    @else {
        @include _apply-modifier('internal-state', $args...) {        
            @content;
        }
    }   
}


/// Extend current selector by super component state.
///
/// It is appling the nearest super component with given state selector.
///
/// If first argument is an number, it is the index of supper component (positive number means from top 1, negative from nearest super element -1).
///
/// @group Component
/// @access public
/// @deprecated from version 2+, use just +state('identifier',-1) or other negative index.
/// @param { String } $args... - selector extension(s) = state names
/// @content
/// @throw See errors of mixin _super-modifier and _apply-modifier.
/// @output It will output selector extended by given super component state(s) with given content.
@mixin super-state($args...) {
    @include _super-modifier('super-state', $args...) {
        @content;
    }
}


/// Extend current selector by super component variant.
///
/// It is appling the nearest super component with given variant selector.
///
/// If first argument is an number, it is the index of supper component (positive number means from top 1, negative from nearest super element -1).
///
/// @group Component
/// @access public
/// @deprecated from version 2+, use just +variant('identifier',-1) or other negative index.
/// @param { String } $args... - selector extension(s) = variant names
/// @content
/// @throw See errors of mixin _super-modifier and _apply-modifier.
/// @output It will output selector extended by given super component variant(s) with given content.
@mixin super-variant($args...) {
    @include _super-modifier('super-variant', $args...) {
        @content;
    }
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register context in current component.
///
/// 2) when used outside of register mixin, it will apply given context(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require context selector and optional alias OR when not in regiter mode selector extension(s) = context names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given context(s) with given content.
/// @throw SPOT CSS: context/no-global-found - you entered only alias of context mutation '{alias}'. No global context found with this alias or maybe you wanted provide second argument with context selector.
@mixin context($args...) {
    @if $_is-register-mode {
        // if only alias is given (one argument), check if it's registered with `global-responsive` mixin
        @if length($args)==1 and _is-alias(first($args)) {
            $alias: _normalize-alias(first($args));
         
            $already-registered-alias: map-get($_registered-global-contexts, $alias);
            @if $already-registered-alias==null {
                @error $SPOT_ERROR_PREFIX + "context/no-global-found - you entered only alias of context mutation '"+first($args)+"'. No global context found with this alias or maybe you wanted provide second argument with context selector.";
            }

            $args: append($args, $already-registered-alias);
        }

        // ' &' appendix signalize different mode of composing selector
        @include _register-modifiers('context &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of composing selector
        @include _apply-modifier('context &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin context but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
/// @throw SPOT CSS: browser/no-global-found - you entered only alias of browser mutation '{alias}'. No global browser found with this alias or maybe you wanted provide second argument with context selector.
@mixin browser($args...) {
    @if $_is-register-mode {
        // if only alias is given (one argument), check if it's registered with `global-responsive` mixin
        @if length($args)==1 and _is-alias(first($args)) {
            $alias: _normalize-alias(first($args));
         
            $already-registered-alias: map-get($_registered-global-browsers, $alias);
            @if $already-registered-alias==null {
                @error $SPOT_ERROR_PREFIX + "browser/no-global-found - you entered only alias of browser mutation '"+first($args)+"'. No global browser found with this alias or maybe you wanted provide second argument with context selector.";
            }

            $args: append($args, $already-registered-alias);
        }

        // ' &' appendix signalize different mode of  composing selector
        @include _register-modifiers('browser &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composing selector
        @include _apply-modifier('browser &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin context but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
/// @throw SPOT CSS: responsive/no-global-found - you entered only alias of responsive mutation '{alias}'. No global responsive found with this alias or maybe you wanted provide second argument with media query.
@mixin responsive($args...) {
    @if $_is-register-mode {
        // if only alias is given (one argument), check if it's registered with `global-responsive` mixin
        @if length($args)==1 and _is-alias(first($args)) {
            $alias: _normalize-alias(first($args));
         
            $already-registered-alias: map-get($_registered-global-responsives, $alias);
            @if $already-registered-alias==null {
                @error $SPOT_ERROR_PREFIX + "responsive/no-global-found - you entered only alias of responsive mutation '"+first($args)+"'. No global responsive found with this alias or maybe you wanted provide second argument with media query.";
            }

            $args: append($args, $already-registered-alias);
        }

        // ' &' appendix signalize different mode of  composing selector
        @include _register-modifiers('responsive &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composing selector
        @include _apply-modifier('responsive &', $args...) {        
            @content;
        }
    }   
}

/// Same as mixin responsive or context but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
/// @throw SPOT CSS: theme/no-global-found - you entered only alias of theme mutation '{alias}'. No global theme found with this alias or maybe you wanted provide second argument with selecotr or media query or expression.
@mixin theme($args...) {
    @if $_is-register-mode {
        // if only alias is given (one argument), check if it's registered with `global-responsive` mixin
        @if length($args)==1 and _is-alias(first($args)) {
            $alias: _normalize-alias(first($args));
         
            $already-registered-alias: map-get($_registered-global-themes, $alias);
            @if $already-registered-alias==null {
                @error $SPOT_ERROR_PREFIX + "theme/no-global-found - you entered only alias of theme mutation '"+first($args)+"'. No global theme found with this alias or maybe you wanted provide second argument with selecotr or media query or expression.";
            }

            $args: append($args, $already-registered-alias);
        }

        // ' &' appendix signalize different mode of composing selector
        @include _register-modifiers('theme &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of composing selector
        @include _apply-modifier('theme &', $args...) {        
            @content;
        }
    }   
}

/// Prepend inner context before current sub element of the component.
/// @group Component
/// @access public
/// @param { String } $selectors Context selector with "+" or "~" combinator selector, it could be multiple selectors.
/// @content
/// @example
///   +inner-context('h1 +')
///   +inner-context('h1 ~, h2 ~')
///   +inner-context('h1 ~', 'h2 ~')
@mixin inner-context($selectors...) {
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "inner-context/in-register - the mixin inner-context doesn't have to be registered in register mixin in component '"+component()+"'.";
    }
    @else {
        // @TODO should contain "+" or "~" combinator selector (at the end of the selector)

        // @TODO should not be used in root element of component.

        // force using 'default' mixin when using modifiers
        @if not _default-mixin-was-already-called() and $_current-component-mode!='draft' {
            @error $SPOT_ERROR_PREFIX + "inner-context/default-is-missing - the inner-context '"+inspect($selectors)+"' in component '"+top-component()+"' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).";
        }
        
        @each $selector in $selectors {
            $multiple-selectors: selector-parse(#{$selector});

            $output: (); // not []; because error "Expected identifier." @at-root #{$output} of some versions of SASS
            @each $sel in $multiple-selectors {
                $sel: $sel+'';
                $current-end-sel: self()+'';
                
                // Exception: if current (last selector) contains '>' at the beginning, e.g '> .image'
                @if str-index($current-end-sel, '>')==1 {
                    $current-end-sel: str-trim(str-slice($current-end-sel, 2)); // trim the '> ';

                    // Exception: if $sel (prepending selector) is '.image +' or '+ image', it will output still the same result
                    // the first one works fine ('.image +'), but for the other ('+ image') we have to move '+' at the end (same goes for '~')
                    @if str-index($sel, '+')==1 or str-index($sel, '~')==1 {
                        $first-char: str-slice($sel, 1, 1);
                        $rest-sel: str-trim(str-slice($sel+'', 2));
                        // Constrain: it should be done only when $current-end-sel is equal to $sel (prepending selector) => e.g. resulting to '> .image + .image'
                        @if $current-end-sel==$rest-sel {
                            $sel: $rest-sel + ' ' +  $first-char;
                        }
                    }
                }

                $output: append($output, _replace-component-subselector(&, $current-end-sel, str-trim($sel) + ' ' + $current-end-sel), 'comma');
            }
            @at-root #{$output} {
                @content;
            }
        }
    }
}


/// Element mixin to define sub elements in component.
///
/// Context, responsive and browser modifiers are inherited from parent component but element can register also its own.
///
/// 1) It checks if same element is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Elements can be nested one into another.
///
/// @group Component
/// @access public
/// @since from version 2.0.0
/// @param { String } $selector - single selector of sub element of component. It has to be single and simple selector.
/// @content
/// @throw SPOT CSS: element/no-selectors - at least one selector is expected.
/// @throw SPOT CSS: element/no-component - you cannot use mixin element outside of component.
/// @throw SPOT CSS: element/in-modifier - it is not allowed to use element in modifier '{current_modifier}'.
/// @throw SPOT CSS: element/in-default - it is not allowed to call element mixin in default mixin (in component '{component}).
/// @throw SPOT CSS: element/missing-separator - there is sub-element separator mixin (_______) missing before element mixin (in component '{component}').
/// @throw SPOT CSS: element/already-registered - trying to register already registered element '{selector}' for component '{component}'.
/// @throw SPOT CSS: element/unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @throw SPOT CSS: element/duplicate - given element selector is already used in current block ('{selector}').";
/// @throw SPOT CSS: element/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: element/single-selector - given selector is not a single selector, because contains comma(s): '{selector}'.
/// @throw SPOT CSS: element/simple-selector - given selector has to be simple selector withou spaces, '>' and '~' but is: '{selector}'.
/// @throw SPOT CSS: element-alias/not-first-argument - You can use alias only as a firt argument only. But you are using argument with alias '{alias}' for component selector '{selector}' wrong.
/// @throw SPOT CSS: element-alias/already-registered - trying to register already registered sub-element '{alias}' for component selector '{selector}'.
/// @throw SPOT CSS: element-alias/unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @output Given selector with given content.
@mixin element($selectors...) {
    @if length($selectors)==0 {
        @error $SPOT_ERROR_PREFIX + "element/no-selectors - at least one selector is expected.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "element/no-component - you cannot use mixin element outside of component.";
    }

    // do not allow in modifier
    @if $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "element/in-modifier - it is not allowed to use element in modifier '"+$_current_modifier+"'.";
    }

    // do not allow in default mutation
    @if $_is-default-mode {
        @error $SPOT_ERROR_PREFIX + "element/in-default - it is not allowed to call element mixin in default mixin (in component '"+component()+"').";
    }

    // check for separator ____________________________
    @if not $_is-register-mode and not $_was-used-sub-element-separator and spot-get(force-element-separator) {
        @warn $SPOT_ERROR_PREFIX + "element/missing-separator - there is sub-element separator mixin (_______) missing before element mixin in component ('"+component()+"').";
    }
    // reset flag for next (sub)element
    $_was-used-sub-element-separator: false !global;

    // test for not empty and single selector
    @each $selector in $selectors {
        @if not $selector or $selector=="" {
            @error $SPOT_ERROR_PREFIX + "element/no-selector - selector was expected but nothing passed.";
        }
        @if not _is-alias($selector) {
            $parts: selector-parse($selector);
            @if length($parts) > 1 {
                @error $SPOT_ERROR_PREFIX + "element/single-selector - given selector is not a single selector, because contains comma(s): '"+$selector+"'.";
            }

            @if length-of-simple-selector(selector-trim-combinators($selector)) > 1 {            
                @error $SPOT_ERROR_PREFIX + "element/simple-selector - given selector has to be simple selector withou spaces, '>' and '~' but is: '"+$selector+"'.";
            }
        }
    }
    
    @if $_is-register-mode { 
        $counter: 0;
        $selectors-without-alias: shift($selectors); // remove first item (alias)
        
        $alias: null;
        $component-alias-key: null;
        $registered-component-alias: null;

        @each $selector in $selectors {            
            $counter: $counter + 1;

            @if _is-alias($selector) {
                @if $counter>1 {
                    // @TODO test
                    @error $SPOT_ERROR_PREFIX + "element-alias/not-first-argument - You can use alias only as a firt argument only. But you are using argument with alias '"+$alias+"' for component selector '"+&+"' wrong.";
                }
                
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                $registered-component-element-alias: map-get($_registered-component-element-aliases, $component-alias-key);
                
                // guarding duplicity of sub-elements alias (for whole component)
                @if $registered-component-alias and (($registered-component-element-alias and str-index(&+'', $registered-component-element-alias+'')==1) or $registered-component-alias!=$selectors-without-alias) {
                    @error $SPOT_ERROR_PREFIX + "element-alias/already-registered - trying to register already registered sub-element '"+$alias+"' for component selector '"+&+"'.";
                }
                
                $registered-component-alias: $selectors-without-alias;
                $_registered-component-aliases: map-merge($_registered-component-aliases, ($component-alias-key: $registered-component-alias)) !global;
                $_registered-component-element-aliases: map-merge($_registered-component-element-aliases, ($component-alias-key: &)) !global;
            }
            @else {
                // if not alias
                $selector: selector-parse($selector)+''; // normalize selector (e.g. ">li" => "> li")
                $sub-component-selector: #{ & + ' ' + str-trim($selector) };
                
                @include _check-duplicity-of-sub-selectors('element', $sub-component-selector, $selector);

                // store current component selector (into stack)
                $_current-components: append($_current-components, $selector, 'space') !global;

                $_is-child-component-mode: true !global;

                @at-root
                #{$sub-component-selector} {
                    @content;
                }

                $_is-child-component-mode: false !global;

                // remove current component selector (from stack)
                $_current-components: pop($_current-components) !global;
            }
        }        
    }
    @else {
        // store appling sub element in current selector to avoid calling state, variant, etc. after element section (see error "/invalid-order")
        @if not index($_selectors-with-sub-elements, &) {
            $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
        }

        // expand aliases to selectors
        @for $i from 1 through length($selectors) {
            $selector: nth($selectors, $i);
            @if _is-alias($selector) {
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                
                @if not $registered-component-alias {
                    @error $SPOT_ERROR_PREFIX + "element-alias/unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
                }

                $selectors: replace-nth($selectors, $i, $registered-component-alias);
            }
        }

        // set for function only-for
        $was-set-here: false;
        @if length($selectors)>1 and $_current-element-selectors-for-only-for=='' {
            $_current-element-selectors-for-only-for: #{join-list-to-string($selectors, ', ')} !global;
            $was-set-here: true;
        }

        @each $selector in $selectors {
            $selector: selector-parse($selector)+''; // normalize selector (e.g. ">li" => "> li")
            $sub-component-selector: #{ & + ' ' + str-trim($selector) };
            // check if element is registered
            @if not _is-already-used-selectors($sub-component-selector) and $_current-component-mode!='draft' {
                @error $SPOT_ERROR_PREFIX + "element/unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
            }
            // 1)
            // if already registred
            @if index($_registered-components, $sub-component-selector)!=null {
                @error $SPOT_ERROR_PREFIX + "element/duplicate - given element selector is already used in current block ('"+$sub-component-selector+"').";
            }
            @else {
                // store component selector if is not stored yet
                $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
                @include _register-already-used-multiple-selectors($sub-component-selector);
            }

            // 2)
            // store current component selector (into stack)
            $_current-components: append($_current-components, $selector, 'space') !global;

            $_is-child-component-mode: true !global;

            @at-root
            #{$sub-component-selector} {
                @content;
            }

            $_is-child-component-mode: false !global;

            // remove current component selector (from stack)
            $_current-components: pop($_current-components) !global;
        }

        // unset
        @if $_current-element-selectors-for-only-for!='' and $was-set-here {
            $_current-element-selectors-for-only-for: '' !global;
        }
    }
}


/// SPOT exception element mixin to define sub elements in component when SPOT rule is broken.
/// It doesn't have to be a simle selector!
/// Aliases must be unique also in +element scope, but selectors can have duplicities with +element (because +spot-exception-element).
/// @example +spot-exception-element('>*+*') - addressing all direct children even if it is part of another component or concrete sub-elements are adressed later.
///
/// @group Component
/// @access public
/// @since from version 2.0.0
/// @param { String } $selector - single selector of sub element of component. 
/// @content
/// @throw SPOT CSS: spot-exception-element/no-selectors - at least one selector is expected.
/// @throw SPOT CSS: spot-exception-element/no-component - you cannot use mixin element outside of component.
/// @throw SPOT CSS: spot-exception-element/in-modifier - it is not allowed to use element in modifier '{current_modifier}'.
/// @throw SPOT CSS: spot-exception-element/in-default - it is not allowed to call element mixin in default mixin (in component '{component}).
/// @throw SPOT CSS: spot-exception-element/missing-separator - there is sub-element separator mixin (_______) missing before element mixin (in component '{component}').
/// @throw SPOT CSS: spot-exception-element/already-registered - trying to register already registered element '{selector}' for component '{component}'.
/// @throw SPOT CSS: spot-exception-element/unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @throw SPOT CSS: spot-exception-element/duplicate - given element selector is already used in current block ('{selector}').";
/// @throw SPOT CSS: spot-exception-element/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: spot-exception-element/single-selector - given selector is not a single selector, because contains comma(s): '{selector}'.
/// @throw SPOT CSS: spot-exception-element/alias-not-first-argument - You can use alias only as a firt argument only. But you are using argument with alias '{alias}' for component selector '{selector}' wrong.
/// @throw SPOT CSS: spot-exception-element/alias-already-registered - trying to register already registered sub-element '{alias}' for component selector '{selector}'.
/// @throw SPOT CSS: spot-exception-element/alias-unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @output Given selector with given content.
@mixin spot-exception-element($selectors...) {
    @if length($selectors)==0 {
        @error $SPOT_ERROR_PREFIX + "spot-exception-element/no-selectors - at least one selector is expected.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "spot-exception-element/no-component - you cannot use this mixin outside of component.";
    }

    // do not allow in modifier
    @if $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "spot-exception-element/in-modifier - it is not allowed to use element in modifier '"+$_current_modifier+"'.";
    }

    // do not allow in default mutation
    @if $_is-default-mode {
        @error $SPOT_ERROR_PREFIX + "spot-exception-element/in-default - it is not allowed to call element mixin in default mixin (in component '"+component()+"').";
    }

    // check for separator ____________________________
    @if not $_is-register-mode and not $_was-used-sub-element-separator and spot-get(force-element-separator) {
        @warn $SPOT_ERROR_PREFIX + "spot-exception-element/missing-separator - there is sub-element separator mixin (_______) missing before element mixin in component ('"+component()+"').";
    }
    // reset flag for next (sub)element
    $_was-used-sub-element-separator: false !global;

    // test for not empty and single selector
    @each $selector in $selectors {
        @if not $selector or $selector=="" {
            @error $SPOT_ERROR_PREFIX + "spot-exception-element/no-selector - selector was expected but nothing passed.";
        }
        @if not _is-alias($selector) {
            $parts: selector-parse($selector);
            @if length($parts) > 1 {
                @error $SPOT_ERROR_PREFIX + "spot-exception-element/single-selector - given selector is not a single selector, because contains comma(s): '"+$selector+"'.";
            }
        }
    }
    
    @if $_is-register-mode { 
        $counter: 0;
        $selectors-without-alias: shift($selectors); // remove first item (alias)
        
        $alias: null;
        $component-alias-key: null;
        $registered-component-alias: null;

        @each $selector in $selectors {            
            $counter: $counter + 1;

            @if _is-alias($selector) {
                @if $counter>1 {
                    // @TODO test
                    @error $SPOT_ERROR_PREFIX + "spot-exception-element/alias-not-first-argument - You can use alias only as a firt argument only. But you are using argument with alias '"+$alias+"' for component selector '"+&+"' wrong.";
                }
                
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                $registered-component-element-alias: map-get($_registered-component-element-aliases, $component-alias-key);
                
                // guarding duplicity of sub-elements alias (for whole component)
                @if $registered-component-alias and (($registered-component-element-alias and str-index(&+'', $registered-component-element-alias+'')==1) or $registered-component-alias!=$selectors-without-alias) {
                    @error $SPOT_ERROR_PREFIX + "spot-exception-element/alias-already-registered - trying to register already registered sub-element '"+$alias+"' for component selector '"+&+"'.";
                }
                
                $registered-component-alias: $selectors-without-alias;
                $_registered-component-aliases: map-merge($_registered-component-aliases, ($component-alias-key: $registered-component-alias)) !global;
                $_registered-component-element-aliases: map-merge($_registered-component-element-aliases, ($component-alias-key: &)) !global;
            }
            @else {
                // if not alias
                $selector: selector-parse($selector)+''; // normalize selector (e.g. ">li" => "> li")
                $sub-component-selector: #{ & + ' ' + str-trim($selector) };
                
                @include _check-duplicity-of-sub-selectors-for-spot-exception-element('spot-exception-element', $sub-component-selector, $selector);

                // store current component selector (into stack)
                $_current-components: append($_current-components, $selector, 'space') !global;

                $_is-child-component-mode: true !global;

                @at-root
                #{$sub-component-selector} {
                    @content;
                }

                $_is-child-component-mode: false !global;

                // remove current component selector (from stack)
                $_current-components: pop($_current-components) !global;
            }
        }        
    }
    @else {
        // store appling sub element in current selector to avoid calling state, variant, etc. after element section (see error "/invalid-order")
        @if not index($_selectors-with-sub-elements, &) {
            $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
        }

        // expand aliases to selectors
        @for $i from 1 through length($selectors) {
            $selector: nth($selectors, $i);
            @if _is-alias($selector) {
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                
                @if not $registered-component-alias {
                    @error $SPOT_ERROR_PREFIX + "spot-exception-element/alias-unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
                }

                $selectors: replace-nth($selectors, $i, $registered-component-alias);
            }
        }

        // set for function only-for
        $was-set-here: false;
        @if length($selectors)>1 and $_current-element-selectors-for-only-for=='' {
            $_current-element-selectors-for-only-for: #{join-list-to-string($selectors, ', ')} !global;
            $was-set-here: true;
        }

        @each $selector in $selectors {
            $selector: selector-parse($selector)+''; // normalize selector (e.g. ">li" => "> li")
            $sub-component-selector: #{ & + ' ' + str-trim($selector) };
            // check if element is registered
            @if not _is-already-used-selectors-for-spot-exception-element($sub-component-selector) and $_current-component-mode!='draft' {
                @error $SPOT_ERROR_PREFIX + "spot-exception-element/unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
            }
            // 1)
            // if already registred
            @if index($_registered-components-for-spot-exception-element, $sub-component-selector)!=null {
                @error $SPOT_ERROR_PREFIX + "spot-exception-element/duplicate - given element selector is already used in current block ('"+$sub-component-selector+"').";
            }
            @else {
                // store component selector if is not stored yet
                $_registered-components-for-spot-exception-element: append($_registered-components-for-spot-exception-element, $sub-component-selector, 'comma') !global;
                $_already-used-multiple-selectors-for-spot-exception-element: append($_already-used-multiple-selectors-for-spot-exception-element, $sub-component-selector, 'comma') !global;
            }

            // 2)
            // store current component selector (into stack)
            $_current-components: append($_current-components, $selector, 'space') !global;

            $_is-child-component-mode: true !global;

            @at-root
            #{$sub-component-selector} {
                @content;
            }

            $_is-child-component-mode: false !global;

            // remove current component selector (from stack)
            $_current-components: pop($_current-components) !global;
        }

        // unset
        @if $_current-element-selectors-for-only-for!='' and $was-set-here {
            $_current-element-selectors-for-only-for: '' !global;
        }
    }
}


/// SPOT exception selector mixin to define sub elements in component when SPOT rule is broken.
/// It doesn't have to be a simle selector!
/// Aliases must be unique also in +element scope, but selectors can have duplicities with +element (because +spot-exception-element).
/// @example +spot-exception-element('>*+*') - addressing all direct children even if it is part of another component or concrete sub-elements are adressed later.
///
/// @group Component
/// @access public
/// @since from version 2.0.0
/// @param { String } $selector - single selector of sub element of component. 
/// @content
/// @throw SPOT CSS: spot-exception-selector/no-selectors - at least one selector is expected.
/// @throw SPOT CSS: spot-exception-selector/no-component - you cannot use mixin element outside of component.
/// @throw SPOT CSS: spot-exception-selector/already-registered - trying to register already registered element '{selector}' for component '{component}'.
/// @throw SPOT CSS: spot-exception-selector/unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @throw SPOT CSS: spot-exception-selector/duplicate - given element selector is already used in current block ('{selector}').";
/// @throw SPOT CSS: spot-exception-selector/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: spot-exception-selector/single-selector - given selector is not a single selector, because contains comma(s): '{selector}'.
/// @throw SPOT CSS: spot-exception-selector/alias-not-first-argument - You can use alias only as a firt argument only. But you are using argument with alias '{alias}' for component selector '{selector}' wrong.
/// @throw SPOT CSS: spot-exception-selector/alias-already-registered - trying to register already registered sub-element '{alias}' for component selector '{selector}'.
/// @throw SPOT CSS: spot-exception-selector/alias-unknown-unregistered - given element '{selector}' is not registered in direct parent component ('{component}').
/// @output Given selector with given content.
@mixin spot-exception-selector($selectors...) {
    @if length($selectors)==0 {
        @error $SPOT_ERROR_PREFIX + "spot-exception-selector/no-selectors - at least one selector is expected.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "spot-exception-selector/no-component - you cannot use mixin element outside of component.";
    }

    // there can be but it is not required to have +____________ separator before this mixin
    // reset flag for next (sub)element
    $_was-used-sub-element-separator: false !global;

    // test for not empty and single selector
    @each $selector in $selectors {
        @if not $selector or $selector=="" {
            @error $SPOT_ERROR_PREFIX + "spot-exception-selector/no-selector - selector was expected but nothing passed.";
        }
        @if not _is-alias($selector) {
            $parts: selector-parse($selector);
            @if length($parts) > 1 {
                @error $SPOT_ERROR_PREFIX + "spot-exception-selector/single-selector - given selector is not a single selector, because contains comma(s): '"+$selector+"'.";
            }
        }
    }
    
    @if $_is-register-mode { 
        $counter: 0;
        $selectors-without-alias: shift($selectors); // remove first item (alias)
        
        $alias: null;
        $component-alias-key: null;
        $registered-component-alias: null;

        @each $selector in $selectors {            
            $counter: $counter + 1;

            @if _is-alias($selector) {
                @if $counter>1 {
                    // @TODO test
                    @error $SPOT_ERROR_PREFIX + "spot-exception-selector/alias-not-first-argument - You can use alias only as a firt argument only. But you are using argument with alias '"+$alias+"' for component selector '"+&+"' wrong.";
                }
                
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                $registered-component-element-alias: map-get($_registered-component-element-aliases, $component-alias-key);
                
                // guarding duplicity of sub-elements alias (for whole component)
                @if $registered-component-alias and (($registered-component-element-alias and str-index(&+'', $registered-component-element-alias+'')==1) or $registered-component-alias!=$selectors-without-alias) {
                    @error $SPOT_ERROR_PREFIX + "spot-exception-selector/alias-already-registered - trying to register already registered sub-element '"+$alias+"' for component selector '"+&+"'.";
                }
                
                $registered-component-alias: $selectors-without-alias;
                $_registered-component-aliases: map-merge($_registered-component-aliases, ($component-alias-key: $registered-component-alias)) !global;
                $_registered-component-element-aliases: map-merge($_registered-component-element-aliases, ($component-alias-key: &)) !global;
            }
            @else {
                // if not alias
                $selector: selector-parse($selector)+''; // normalize selector (e.g. ">li" => "> li")
                $sub-component-selector: #{ str-trim($selector) };
                
                @include _check-duplicity-of-sub-selectors-for-spot-exception-selector('spot-exception-selector', $sub-component-selector, $selector);

                // store current component selector (into stack)
                $_current-components: append($_current-components, $selector, 'space') !global;

                $_is-child-component-mode: true !global;

                @at-root
                #{$sub-component-selector} {
                    @content;
                }

                $_is-child-component-mode: false !global;

                // remove current component selector (from stack)
                $_current-components: pop($_current-components) !global;
            }
        }        
    }
    @else {
        // store appling sub element in current selector to avoid calling state, variant, etc. after element section (see error "/invalid-order")
        @if not index($_selectors-with-sub-elements, &) {
            $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
        }

        // expand aliases to selectors
        @for $i from 1 through length($selectors) {
            $selector: nth($selectors, $i);
            @if _is-alias($selector) {
                $alias: _normalize-alias($selector);
                $component-alias-key: top-component()+' '+$alias;
                $registered-component-alias: map-get($_registered-component-aliases, $component-alias-key);
                
                @if not $registered-component-alias {
                    @error $SPOT_ERROR_PREFIX + "spot-exception-selector/alias-unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
                }

                $selectors: replace-nth($selectors, $i, $registered-component-alias);
            }
        }

        // set for function only-for
        $was-set-here: false;
        @if length($selectors)>1 and $_current-element-selectors-for-only-for=='' {
            $_current-element-selectors-for-only-for: #{join-list-to-string($selectors, ', ')} !global;
            $was-set-here: true;
        }

        @each $selector in $selectors {
            $selector: selector-parse($selector)+''; // normalize selector (e.g. ">li" => "> li")
            $sub-component-selector: #{ str-trim($selector) };
            // check if element is registered
            @if not _is-already-used-selectors-for-spot-exception-selector($sub-component-selector) and $_current-component-mode!='draft' {
                @error $SPOT_ERROR_PREFIX + "spot-exception-selector/unknown-unregistered - given element '"+$selector+"' is not registered in direct parent component ('"+component()+"').";
            }
            // 1)
            // if already registred
            @if index($_registered-components-for-spot-exception-selector, $sub-component-selector)!=null {
                @error $SPOT_ERROR_PREFIX + "spot-exception-selector/duplicate - given element selector is already used in current block ('"+$sub-component-selector+"').";
            }
            @else {
                // store component selector if is not stored yet
                $_registered-components-for-spot-exception-selector: append($_registered-components-for-spot-exception-selector, $sub-component-selector, 'comma') !global;
                $_already-used-multiple-selectors-for-spot-exception-selector: append($_already-used-multiple-selectors-for-spot-exception-selector, $sub-component-selector, 'comma') !global;
            }

            // 2)
            // store current component selector (into stack)
            $_current-components: append($_current-components, $selector, 'space') !global;

            $_is-child-component-mode: true !global;

            @at-root
            #{$sub-component-selector} {
                @content;
            }

            $_is-child-component-mode: false !global;

            // remove current component selector (from stack)
            $_current-components: pop($_current-components) !global;
        }

        // unset
        @if $_current-element-selectors-for-only-for!='' and $was-set-here {
            $_current-element-selectors-for-only-for: '' !global;
        }
    }
}


/// Declares direct child block in current component selector.
/// @group Component
/// @access public
/// @deprecated from version 2+, instead use +element() mixin.
/// @param { String } $selectors... - One or more selectors of direct childs. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: child-element/no-selectors - at least one child selector is expected.
/// @throw SPOT CSS: child-element/in-modifier - it is not allowed to use child-element in modifier 'modifier'.
/// @throw SPOT CSS: child-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: child-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: child-element/multilevel-selector - given selector is not a single selector ('selector'). Just use more child-element mixins nested.
/// @throw SPOT CSS: child-element/already-used - the child-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every child-element.
/// @output Given selector with given content.
@mixin child-element($selectors...) {
    @include _sub-element('child', $selectors...) {
        @content;
    }
}


/// Declares any other then child block in current component selector. 
/// It is same as child-element mixin, but it does not force direct child selector (>) and
/// it could contain multilevel selectors also (e.g. 'div a.disabled span').
/// Note: It is strongly recomended to use <b>child-element</b> mixin everytime it is possible!
/// @group Component
/// @access public
/// @deprecated from version 2+, instead use +element() mixin.
/// @param { String } $selectors... - One or more selectors. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: sub-element/no-selectors - at least one selector is expected.
/// @throw SPOT CSS: sub-element/in-modifier - it is not allowed to use sub-element in modifier 'modifier'.
/// @throw SPOT CSS: sub-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: sub-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: sub-element/already-used - the sub-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every sub-element.
/// @output Given selector with given content.
@mixin sub-element($selectors...) {
    @include _sub-element('sub', $selectors...) {
        @content;
    }
}


/// Declares pseudo element(s) of current component selector.
/// @group Component
/// @access public
/// @param { String } $selectors - pseudo selector 'before', 'after', 'first-letter', 'first-line', 'placeholder' or 'selection' (also prefixes ':' and ':: are accepted)
/// @content
/// @throw SPOT CSS: pseudo-element/no-selectors - at least one pseudo selector is expected.
/// @throw SPOT CSS: pseudo-element/in-modifier - it is not allowed to use pseudo-element in modifier 'modifier'.
/// @throw SPOT CSS: pseudo-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: pseudo-element/invalid-selector - Invalid value for pseudo element 'selector'. Only valid values are 'before', 'after' and other pseudo elements.
/// @throw SPOT CSS: pseudo-element/already-used - the pseudo-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every pseudo-element.
/// @output Given selector with given content.
@mixin pseudo-element($selectors...) {
    @include _sub-element('pseudo', $selectors...) {
        @content;
    }
}


/// Add selector specificity at all levels at once.
/// @access public
/// @param { Number } $id-spec - How many levels to add at id level (1..n)
/// @param { Number } $cl-spec - How many levels to add at class level (1..n)
/// @param { Number } $el-spec - How many levels to add at element level (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-specificity($id-spec: 0, $cl-spec: 0, $el-spec: 0) {
    @at-root #{add-specificity(&, $id-spec, $cl-spec, $el-spec)} {
        @content;
    }
}


/// Add selector specificity at element level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-element-specificity($n) {
    @at-root #{add-element-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at class level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-class-specificity($n) {
    @at-root #{add-class-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at id level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-id-specificity($n) {
    @at-root #{add-id-specificity(&, $n)} {
        @content;
    }
}


/// Outputs specificity in your CSS as (invalid) properties.
/// Please, don't use this mixin in production.
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access public
/// @output specificity (map as string), specificity-value (specificity value as integer)
@mixin specificity() {
    specificity: specificity(&);
    specificity-value: specificity(&, true);
}


/// Override current selector over given selector.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin override($args...) {
    @at-root #{override(&, $args...)} {
        @content;
    }
}


/// Filter given selector with given sub-selectors.
/// Every selector which does not contain any of given args will be excluded.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @throw SPOT CSS: only-for/in-register - the mixin default doesn't have to be registered in register mixin in component 'component'.
/// @throw SPOT CSS: only-for/default-is-missing - the only-for '$args' in component 'component' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).
/// @output Filtered selector(s) with given inner content.
@mixin only-for($args...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "only-for/in-register - the mixin only-for doesn't have to be registered in register mixin in component '"+component()+"'.";
    }
    // force using 'default' mixin when using modifiers
    @if not _default-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "only-for/default-is-missing - the only-for '"+inspect($args)+"' in component '"+component()+"' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).";
    }

    $_backup-of-current-themes-as-expression: $_current-themes-as-expression;

    $selector: only-for(&, $args...);

    $_is-in-only-for-block: true !global;

    @if $selector!='' {
        @at-root #{$selector} {
            @content;
        }
    }

    $_is-in-only-for-block: false !global;
    $_current-themes-as-expression: $_backup-of-current-themes-as-expression !global;
}


/// Register global reusable context mutation addresable with alias.
/// You can use it via alias in component register section.
/// (we recommend to use it in global variables section/file)
///
/// @group Global
/// @access public
/// @param { String } $alias - Unique alias of registered context mutation, e.g. "{mobile}" (must be enclosed in curly brackets).
/// @param { String } $selectorOrMediaQuery - Context selector or media query.
/// @throw SPOT CSS: global-context/bad-alias - alias must be enclosed in curly brackets.
/// @throw SPOT CSS: global-context/no-alias - alias must contain at least one character.
/// @throw SPOT CSS: global-context/duplicate-alias - alias '{alias}' is already registered as a global alias.
@mixin global-context($alias, $selectorOrMediaQuery) {
    $alias: _normalize-alias($alias);

    @if _is-alias($alias)==false {
        @error $SPOT_ERROR_PREFIX + "global-context/bad-alias - alias must be enclosed in curly brackets.";
    }
    
    @if str-length(str-replace($alias, ' ', ''))<=2 {
        @error $SPOT_ERROR_PREFIX + "global-context/no-alias - alias must contain at least one character.";
    }
    
    $already-registered-alias: map-get($_registered-global-contexts, $alias);
    @if $already-registered-alias {
        @error $SPOT_ERROR_PREFIX + "global-context/duplicate-alias - alias '"+$alias+"' is already registered as a global alias.";
    }

    $_registered-global-contexts: map-merge($_registered-global-contexts, ($alias: $selectorOrMediaQuery)) !global;
}


/// Register global reusable responsive mutation addresable with alias.
/// You can use it via alias in component register section.
/// (we recommend to use it in global variables section/file)
///
/// @group Global
/// @access public
/// @param { String } $alias - Unique alias of registered responsive mutation, e.g. "{mobile}" (must be enclosed in curly brackets).
/// @param { String } $selectorOrMediaQuery - Context selector or media query.
/// @throw SPOT CSS: global-responsive/bad-alias - alias must be enclosed in curly brackets.
/// @throw SPOT CSS: global-responsive/no-alias - alias must contain at least one character.
/// @throw SPOT CSS: global-responsive/duplicate-alias - alias '{alias}' is already registered as a global alias.
@mixin global-responsive($alias, $selectorOrMediaQuery) {
    $alias: _normalize-alias($alias);

    @if _is-alias($alias)==false {
        @error $SPOT_ERROR_PREFIX + "global-responsive/bad-alias - alias must be enclosed in curly brackets.";
    }
    
    @if str-length(str-replace($alias, ' ', ''))<=2 {
        @error $SPOT_ERROR_PREFIX + "global-responsive/no-alias - alias must contain at least one character.";
    }
    
    $already-registered-alias: map-get($_registered-global-responsives, $alias);
    @if $already-registered-alias {
        @error $SPOT_ERROR_PREFIX + "global-responsive/duplicate-alias - alias '"+$alias+"' is already registered as a global alias.";
    }

    $_registered-global-responsives: map-merge($_registered-global-responsives, ($alias: $selectorOrMediaQuery)) !global;
}


/// Register global reusable theme mutation addresable with alias.
/// You can use it via alias in component register section.
/// (we recommend to use it in global variables section/file)
///
/// @group Global
/// @access public
/// @param { String } $alias - Unique alias of registered theme mutation, e.g. "{dark}" (must be enclosed in curly brackets).
/// @param { String } $selectorOrMediaQuery - Context selector or media query.
/// @throw SPOT CSS: global-theme/bad-alias - alias must be enclosed in curly brackets.
/// @throw SPOT CSS: global-theme/no-alias - alias must contain at least one character.
/// @throw SPOT CSS: global-theme/duplicate-alias - alias '{alias}' is already registered as a global alias.
@mixin global-theme($alias, $selectorOrMediaQueryOrExpression) {
    $alias: _normalize-alias($alias);

    @if _is-alias($alias)==false {
        @error $SPOT_ERROR_PREFIX + "global-theme/bad-alias - alias must be enclosed in curly brackets.";
    }
    
    @if str-length(str-replace($alias, ' ', ''))<=2 {
        @error $SPOT_ERROR_PREFIX + "global-theme/no-alias - alias must contain at least one character.";
    }
    
    $already-registered-alias: map-get($_registered-global-themes, $alias);
    @if $already-registered-alias {
        @error $SPOT_ERROR_PREFIX + "global-theme/duplicate-alias - alias '"+$alias+"' is already registered as a global alias.";
    }

    $_registered-global-themes: map-merge($_registered-global-themes, ($alias: $selectorOrMediaQueryOrExpression)) !global;
}


/// Register global reusable browser mutation addresable with alias.
/// You can use it via alias in component register section.
/// (we recommend to use it in global variables section/file)
///
/// @group Global
/// @access public
/// @param { String } $alias - Unique alias of registered browser mutation, e.g. "{mobile}" (must be enclosed in curly brackets).
/// @param { String } $selectorOrMediaQuery - Context selector or media query.
/// @throw SPOT CSS: global-browser/bad-alias - alias must be enclosed in curly brackets.
/// @throw SPOT CSS: global-browser/no-alias - alias must contain at least one character.
/// @throw SPOT CSS: global-browser/duplicate-alias - alias '{alias}' is already registered as a global alias.
@mixin global-browser($alias, $selectorOrMediaQuery) {
    $alias: _normalize-alias($alias);

    @if _is-alias($alias)==false {
        @error $SPOT_ERROR_PREFIX + "global-browser/bad-alias - alias must be enclosed in curly brackets.";
    }
    
    @if str-length(str-replace($alias, ' ', ''))<=2 {
        @error $SPOT_ERROR_PREFIX + "global-browser/no-alias - alias must contain at least one character.";
    }
    
    $already-registered-alias: map-get($_registered-global-browsers, $alias);
    @if $already-registered-alias {
        @error $SPOT_ERROR_PREFIX + "global-browser/duplicate-alias - alias '"+$alias+"' is already registered as a global alias.";
    }

    $_registered-global-browsers: map-merge($_registered-global-browsers, ($alias: $selectorOrMediaQuery)) !global;
}


// @deprecated
@mixin already-defined-in($modifiers...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/in-register - the mixin already-defined-in doesn't have to be registered in register mixin in component '"+component()+"'.";
    }

    // do not allow outside of modifier(s)
    @if not $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/outside-modifiers - it is not allowed to use already-defined-in mixin outside of modifiers.";
    }
    // at least 2 nested modifiers
    $current-modifier-stack: map-get($_current-modifiers-stack, component()); // for this component
    @if length($current-modifier-stack) < 2 {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/at-least-2-modifiers - it is not allowed to use already-defined-in mixin only in single level modifier.";
    }
    // add 'already-defined-in' property into current modifier to the stack
    $current-modifier-stack: map-get($_current-modifiers-stack, component()); // for this component
    $modifier-pointer: map-get($_used-modifiers, component());
    $len: length($current-modifier-stack);
    $parents: []; 
    @each $modifier in $current-modifier-stack {
        $parents: append($parents, $modifier-pointer, 'comma');
        $modifier-pointer: map-get($modifier-pointer, $modifier);
    }
    $map: ('already-defined-in': $modifiers);
    @while length($parents)>0 {
        $i: length($parents);
        $name: nth($current-modifier-stack, $i);
        $last: nth($parents, $i);
        $map: map-merge($last, ($name: $map));
        $parents: nth-delete($parents, -1);
    }
    $_used-modifiers: map-merge($_used-modifiers, (component(): $map)) !global;
}


// Extends selector in the actual selector path
// ($something: '.item', $extenssion: '':first-child, :last-child') => $new-extension: 'item:first-child, item:last-child'
@mixin extend($something, $extension) {
    @at-root #{extend(&, $something, $extension)} {
        @content;
    }
}

@mixin assert($selectors) {
    $result: assert(&, $selectors, true);
    // it throws @warn if something wrong
}


@mixin omit-selector($selectors...) {
    $output: [];
    
    @each $current-selector in & {

        @each $selector in $selectors {
            $multiple-selectors: selector-parse(#{$selector});
            
            // @TODO - test for simple selector

            $current-selector: _replace-component-subselector($current-selector, $selector, '')
        }

        @if str-trim($current-selector+'')!='' {
            $output: append($output, $current-selector, 'comma');
        }            
    }
    
    @at-root #{$output} {
        @content;
    }
}

@mixin combined($args...) {
    $len: length($args);
    @if $len<2 {
        @error $SPOT_ERROR_PREFIX + "combined/at-least-2 - expected at least 2 mutations to be combined.";
    }
    @if $len>5 {
        @error $SPOT_ERROR_PREFIX + "combined/max-5 - mixin `combined` is hard coded to support max 5 mutations. If you need more please contact support.";
    }
    
    $modifiers: ();
    $arguments: ();
    @each $mutation in $args {
        $modifier: _parse-modifier-from-mutation($mutation);
        @if $modifier==null {
            @error $SPOT_ERROR_PREFIX + "combined/unknown-mutation - given mutation '"+$mutation+"' was not recognized.";
        }
        $modifiers: append($modifiers, $modifier, 'comma');

        $mut-args: _parse-args-from-mutation($mutation);
        @if length($mut-args)==0 {
            @error $SPOT_ERROR_PREFIX + "combined/no-args - given mutation '"+$mutation+"' have to have at least one argument.";
        }
        $arguments: append($arguments, $mut-args, 'comma');
    }

    // this has to be hardcoded this way (because @content)
    // (or I just don't know how to do dynamically)
    @if $len==2 {
        @include _combined-2-mutations(nth($modifiers, 1), nth($arguments, 1), nth($modifiers, 2), nth($arguments, 2)) {
            @content;
        }
    }
    @else if $len==3 {
        @include _combined-3-mutations(nth($modifiers, 1), nth($arguments, 1), nth($modifiers, 2), nth($arguments, 2), nth($modifiers, 3), nth($arguments, 3)) {
            @content;
        }
    }
    @else if $len==4 {
        @include _combined-4-mutations(nth($modifiers, 1), nth($arguments, 1), nth($modifiers, 2), nth($arguments, 2), nth($modifiers, 3), nth($arguments, 3), nth($modifiers, 4), nth($arguments, 4)) {
            @content;
        }
    }
    @else if $len==5 {
        @include _combined-5-mutations(nth($modifiers, 1), nth($arguments, 1), nth($modifiers, 2), nth($arguments, 2), nth($modifiers, 3), nth($arguments, 3), nth($modifiers, 4), nth($arguments, 4), nth($modifiers, 5), nth($arguments, 5)) {
            @content;
        }
    }
}


@mixin print($message: 'print current selector info') {
    $text: '_______________________\a';

    @if $message=='print current selector info' {
        $current-selector: &;

        $current: '\a>>> Current selector:\a#{$current-selector}';
        // @TODO
        // current component
        // $previous: '>>> Previous selector:\a#{$selector}';
        // $path: '>>> Current path:\a+component(.comp) +variant(.primary)';
        // content: 'SPOT CSS debug message:\a\a_______________________\a\a#{$previous}\a\a#{$current}\a\a#{$path}'
        $text: $text + $current;
    }
    @else {
        $text: $text + '\a> ' + $message;
    }

    $_component_messages: append($_component_messages, $text, 'comma') !global;    
}


/// Mandatory separator before each sub-element modifier. Use as long as you wish.
@mixin _ { @include _sub-element-separator; }
@mixin __ { @include _sub-element-separator; }
@mixin ___ { @include _sub-element-separator; }
@mixin ____ { @include _sub-element-separator; }
@mixin _____ { @include _sub-element-separator; }
@mixin ______ { @include _sub-element-separator; }
@mixin _______ { @include _sub-element-separator; }
@mixin ________ { @include _sub-element-separator; }
@mixin _________ { @include _sub-element-separator; }
@mixin __________ { @include _sub-element-separator; }
@mixin ___________ { @include _sub-element-separator; }
@mixin ____________ { @include _sub-element-separator; }
@mixin _____________ { @include _sub-element-separator; }
@mixin ______________ { @include _sub-element-separator; }
@mixin _______________ { @include _sub-element-separator; }
@mixin ________________ { @include _sub-element-separator; }
@mixin _________________ { @include _sub-element-separator; }
@mixin __________________ { @include _sub-element-separator; }
@mixin ___________________ { @include _sub-element-separator; }
@mixin ____________________ { @include _sub-element-separator; }
@mixin _____________________ { @include _sub-element-separator; }
@mixin ______________________ { @include _sub-element-separator; }
@mixin _______________________ { @include _sub-element-separator; }
@mixin ________________________ { @include _sub-element-separator; }
@mixin _________________________ { @include _sub-element-separator; }
@mixin __________________________ { @include _sub-element-separator; }
@mixin ___________________________ { @include _sub-element-separator; }
@mixin ____________________________ { @include _sub-element-separator; }
@mixin _____________________________ { @include _sub-element-separator; }
@mixin ______________________________ { @include _sub-element-separator; }
@mixin _______________________________ { @include _sub-element-separator; }
@mixin ________________________________ { @include _sub-element-separator; }
@mixin _________________________________ { @include _sub-element-separator; }
@mixin __________________________________ { @include _sub-element-separator; }
@mixin ___________________________________ { @include _sub-element-separator; }
@mixin ____________________________________ { @include _sub-element-separator; }
@mixin _____________________________________ { @include _sub-element-separator; }
@mixin ______________________________________ { @include _sub-element-separator; }
@mixin _______________________________________ { @include _sub-element-separator; }
@mixin ________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________________________________________ { @include _sub-element-separator; }