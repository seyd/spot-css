/// Main top-level mixin to define component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another (with sub-component mixin).
///
/// @group Component
/// @access public
/// @param { String[] } $args... - 1. ($selector),  2. ($alias, $selector)
/// @content
/// @throw SPOT CSS: component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: component/sub-component - you cannot use mixin component in component. Instead use mixin sub-component and also register it in parent component.
/// @throw SPOT CSS: component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: component/already-registered - given selector is already registered as component ({selector}).
/// @output Given selector with given content.
@mixin component($args...) {
    $selector: first($args);

    @if length($args)==2 {
        $alias: nth($args, 1); // not used here (yet)
        $selector: nth($args, 2);
    }

    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "component/no-selector - selector was expected but nothing passed.";
    }

    @if component()!='' {
        @error $SPOT_ERROR_PREFIX + "component/sub-component - you cannot use mixin component in component. Instead use mixin sub-component and also register it in parent component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $component-selector: $selector;

    // 1)
    // if already registred
    @if index($_registered-components, $component-selector)!=null {
        @error $SPOT_ERROR_PREFIX + "component/already-registered - given selector is already registered as component ('"+$component-selector+"').";
    }
    @else {
        // store component selector if is not stored yet
        $_registered-components: append($_registered-components, $component-selector, 'comma') !global;
    }

    // 2)
    // store current component selector (into stack)
    $_current-components: append($_current-components, $component-selector, 'space') !global;

    // // create map for used modifiers (nested) per component
    // $_used-modifiers: map-merge($_used-modifiers, (component(): ())) !global;
    // $_current-modifiers-stack: map-merge($_current-modifiers-stack, (component(): [])) !global;

    // @debug '-------------------------------';
    // @debug 'Component: '+component();

    #{$component-selector} {
        @content;
    }
    
    // @debug map-get($_used-modifiers, component());
    // @debug map-get($_current-modifiers-stack, component());

    // remove current component selector (from stack)
    $_current-components: pop($_current-components) !global;
}


/// Child-component mixin to define (direct child) sub-component in component (with separate states, variants and sub-elements).
///
/// Context, responsive and browser modifiers are inherited from parent component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another.
///
/// @group Component
/// @access public
/// @param { String } $selector - single selector of sub-component
/// @content
/// @throw SPOT CSS: sub-component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.
/// @throw SPOT CSS: sub-component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('selector').
/// @throw SPOT CSS: sub-component/already-registered - trying to register already registered sub-component 'selector' for component 'component'.
/// @throw SPOT CSS: sub-component/childs-in-register - it is not allowed call any other modifiers and sub element mixins in sub-component in register of component 'component'. Register all those modifiers in register section of sub-component 'selector'.
/// @throw SPOT CSS: sub-component/unknown-unregistered - given sub-component 'selector' is not registered in direct parent component ('component').
/// @throw SPOT CSS: sub-component/duplicate - given selector is already used as sub-component ({selector}).
/// @output Given selector with given content.
@mixin child-component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "child-component/no-selector - selector was expected but nothing passed.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "child-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "child-component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $sub-component-selector: #{ & + ' > ' + $selector };

    // check for separator
    @if not $_is-register-mode and not $_was-used-sub-element-separator {
        @error $SPOT_ERROR_PREFIX + "child-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('"+$sub-component-selector+"').";
    }
    $_was-used-sub-element-separator: false !global;
    
    @if $_is-register-mode { 
        // guarding duplicity of sub-components (and all sub selectors)
        @if index($_already-used-selectors, $sub-component-selector) or index($_registered-sub-components, $sub-component-selector) {
            @error $SPOT_ERROR_PREFIX + "child-component/already-registered - trying to register already registered sub-component '"+$selector+"' for component '"+component()+"'.";
        }
        // store unique sub-component
        $_already-used-selectors: append($_already-used-selectors, $sub-component-selector, 'comma') !global;
        $_registered-sub-components: append($_registered-sub-components, $sub-component-selector, 'comma') !global;

         // store current component selector (into stack)
        $_current-components: append($_current-components, '> '+$selector, 'space') !global;

        $_is-child-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-child-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
    @else {
        // check if sub-component is registered
        @if not index($_already-used-selectors, $sub-component-selector) {
            @error $SPOT_ERROR_PREFIX + "child-component/unknown-unregistered - given sub-component '"+$selector+"' is not registered in direct parent component ('"+$sub-component-selector+"').";
        }
        // 1)
        // if already registred
        @if index($_registered-components, $sub-component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "child-component/duplicate - given selector is already used as sub-component ('"+$sub-component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, '> '+$selector, 'space') !global;

        $_is-child-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-child-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
}

/// Sub-component mixin to define component in component (with separate states, variants and sub-elements).
///
/// Context, responsive and browser modifiers are inherited from parent component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another.
///
/// @group Component
/// @access public
/// @param { String } $selector - single selector of sub-component
/// @content
/// @throw SPOT CSS: sub-component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.
/// @throw SPOT CSS: sub-component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('selector').
/// @throw SPOT CSS: sub-component/already-registered - trying to register already registered sub-component 'selector' for component 'component'.
/// @throw SPOT CSS: sub-component/childs-in-register - it is not allowed call any other modifiers and sub element mixins in sub-component in register of component 'component'. Register all those modifiers in register section of sub-component 'selector'.
/// @throw SPOT CSS: sub-component/unknown-unregistered - given sub-component 'selector' is not registered in direct parent component ('component').
/// @throw SPOT CSS: sub-component/duplicate - given selector is already used as sub-component ({selector}).
/// @output Given selector with given content.
@mixin sub-component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "sub-component/no-selector - selector was expected but nothing passed.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "sub-component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $sub-component-selector: #{ & + ' ' + $selector };

    // check for separator
    @if not $_is-register-mode and not $_was-used-sub-element-separator {
        @error $SPOT_ERROR_PREFIX + "sub-component/missing-separator - there is sub-element separator mixin (_______) missing before sub-compomnent mixin in sub-component ('"+$sub-component-selector+"').";
    }
    $_was-used-sub-element-separator: false !global;
    
    @if $_is-register-mode { 
        // guarding duplicity of sub-components (and all sub selectors)
        @if index($_already-used-selectors, $sub-component-selector) or index($_registered-sub-components, $sub-component-selector) {
            @error $SPOT_ERROR_PREFIX + "sub-component/already-registered - trying to register already registered sub-component '"+$selector+"' for component '"+component()+"'.";
        }
        // store unique sub-component
        $_already-used-selectors: append($_already-used-selectors, $sub-component-selector, 'comma') !global;
        $_registered-sub-components: append($_registered-sub-components, $sub-component-selector, 'comma') !global;

        // store current component selector (into stack)
        $_current-components: append($_current-components, ' '+$selector, 'space') !global;

        $_is-sub-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-sub-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
    @else {
        // check if sub-component is registered
        @if not index($_already-used-selectors, $sub-component-selector) {
            @error $SPOT_ERROR_PREFIX + "sub-component/unknown-unregistered - given sub-component '"+$selector+"' is not registered in direct parent component ('"+$sub-component-selector+"').";
        }
        // 1)
        // if already registred
        @if index($_registered-components, $sub-component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "sub-component/duplicate - given selector is already used as sub-component ('"+$sub-component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, ' '+$selector, 'space') !global;

        $_is-sub-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-sub-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
}


/// Main top-level mixin to define component.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: register/no-component - the mixin register must be used inside a component.
/// @throw SPOT CSS: register/already-called - the mixin register was already called for component 'component'.
/// @output Given selector with given content.
@mixin register {
    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "register/no-component - the mixin register must be used inside a component.";
    }
    
    /// @todo check if was called as first mixin in component
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // run only once per component
    @if _register-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "register/already-called - the mixin register was already called for component '"+component()+"'.";
    }
    @else {
        @include _set_register-mixin-was-already-called();
    }

    $_is-register-mode: true !global;
    @content;
    $_is-register-mode: false !global;
}


/// This mixins defines default component or sub elements style.
/// It is required only when other modifiers are used. 
/// This is not modifier so it has to be not registered in register mixin.
/// This mixin helps only in semantic matter better understanding of component style.
/// If just static style of an element, default mixin is not required.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: default/in-register - the mixin default doesn't have to be registered in register mixin in component 'component'.
/// @throw SPOT CSS: default/already-called - the mixin default was already called for element 'element'.
/// @output Just given content.
@mixin default {
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "default/in-register - the mixin default doesn't have to be registered in register mixin in component '"+component()+"'.";
    }    
    // run only once per component selector
    $current-media-selector: _wrap_into_media_selector(&);
    @if index($_default-called-on, $current-media-selector) {
        @error $SPOT_ERROR_PREFIX + "default/already-called - the mixin default was already called for element '"+$current-media-selector+"'.";
    }
    $_default-called-on: append($_default-called-on, $current-media-selector) !global;
    
    $_is-default-mode: true !global;
    @content;
    $_is-default-mode: false !global;
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register variant in current component.
///
/// 2) when used outside of register mixin, it will apply given variant(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require variant selector (and all values when placeholder '?' is used in variant selector) OR when not in regiter mode selector extension(s) = variant names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given variant(s) with given content.
@mixin variant($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('variant', $args...);
    }
    @else {
        @include _apply-modifier('variant', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>variant</b> but different semantic naming.
/// @see {mixin} variant
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin state($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('state', $args...);
    }
    @else {
        @include _apply-modifier('state', $args...) {        
            @content;
        }
    }   
}


/// Mixin for register and apply internal state of component. 
/// Difference between internal-state and state mixin is that internal-state 
/// is binded to component element or sub-element where is internal-state registered in register mixin.
/// It works as super-state so it is looking to parent elements where internal-state is registered. 
/// @see {mixin} variant
/// @group Component
/// @access public
/// @param { String } $args... Same as for state mixin.
/// @content
/// @output It will output selector extended by given internal-state(s) with given content.
@mixin internal-state($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('internal-state', $args...);
    }
    @else {
        @include _apply-modifier('internal-state', $args...) {        
            @content;
        }
    }   
}


/// Extend current selector by super component state.
///
/// It is appling the nearest super component with given state selector.
///
/// If first argument is an number, it is the index of supper component (positive number means from top 1, negative from nearest super element -1).
///
/// @group Component
/// @access public
/// @param { String } $args... - selector extension(s) = state names
/// @content
/// @throw See errors of mixin _super-modifier and _apply-modifier.
/// @output It will output selector extended by given super component state(s) with given content.
@mixin super-state($args...) {
    @include _super-modifier('super-state', $args...) {
        @content;
    }
}


/// Extend current selector by super component variant.
///
/// It is appling the nearest super component with given variant selector.
///
/// If first argument is an number, it is the index of supper component (positive number means from top 1, negative from nearest super element -1).
///
/// @group Component
/// @access public
/// @param { String } $args... - selector extension(s) = variant names
/// @content
/// @throw See errors of mixin _super-modifier and _apply-modifier.
/// @output It will output selector extended by given super component variant(s) with given content.
@mixin super-variant($args...) {
    @include _super-modifier('super-variant', $args...) {
        @content;
    }
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register context in current component.
///
/// 2) when used outside of register mixin, it will apply given context(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require context selector and optional alias OR when not in regiter mode selector extension(s) = context names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given context(s) with given content.
@mixin context($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('context &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('context &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>context</b> but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin browser($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('browser &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('browser &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>context</b> but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin responsive($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('responsive &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('responsive &', $args...) {        
            @content;
        }
    }   
}


/// Declares direct child block in current component selector.
/// @group Component
/// @access public
/// @param { String } $selectors... - One or more selectors of direct childs. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: child-element/no-selectors - at least one child selector is expected.
/// @throw SPOT CSS: child-element/in-modifier - it is not allowed to use child-element in modifier 'modifier'.
/// @throw SPOT CSS: child-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: child-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: child-element/multilevel-selector - given selector is not a single selector ('selector'). Just use more child-element mixins nested.
/// @throw SPOT CSS: child-element/already-used - the child-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every child-element.
/// @output Given selector with given content.
@mixin child-element($selectors...) {
    @include _sub-element('child', $selectors...) {
        @content;
    }
}


/// Declares any other then child block in current component selector. 
/// It is same as child-element mixin, but it does not force direct child selector (>) and
/// it could contain multilevel selectors also (e.g. 'div a.disabled span').
/// Note: It is strongly recomended to use <b>child-element</b> mixin everytime it is possible!
/// @group Component
/// @access public
/// @param { String } $selectors... - One or more selectors. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: sub-element/no-selectors - at least one selector is expected.
/// @throw SPOT CSS: sub-element/in-modifier - it is not allowed to use sub-element in modifier 'modifier'.
/// @throw SPOT CSS: sub-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: sub-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: sub-element/already-used - the sub-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every sub-element.
/// @output Given selector with given content.
@mixin sub-element($selectors...) {
    @include _sub-element('sub', $selectors...) {
        @content;
    }
}


/// Declares pseudo element(s) of current component selector.
/// @group Component
/// @access public
/// @param { String } $selectors - pseudo selector 'before', 'after', 'first-letter', 'first-line', 'placeholder' or 'selection' (also prefixes ':' and ':: are accepted)
/// @content
/// @throw SPOT CSS: pseudo-element/no-selectors - at least one pseudo selector is expected.
/// @throw SPOT CSS: pseudo-element/in-modifier - it is not allowed to use pseudo-element in modifier 'modifier'.
/// @throw SPOT CSS: pseudo-element/in-default - it is not allowed to call child-element mixin in default mixin (in component 'component').
/// @throw SPOT CSS: pseudo-element/invalid-selector - Invalid value for pseudo element 'selector'. Only valid values are 'before', 'after', 'first-letter', 'first-line', 'placeholder' or 'selection'.
/// @throw SPOT CSS: pseudo-element/already-used - the pseudo-element('selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every pseudo-element.
/// @output Given selector with given content.
@mixin pseudo-element($selectors...) {
    @include _sub-element('pseudo', $selectors...) {
        @content;
    }
}


/// Add selector specificity at element level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-element-specificity($n) {
    @at-root #{add-element-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at class level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-class-specificity($n) {
    @at-root #{add-class-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at id level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-id-specificity($n) {
    @at-root #{add-id-specificity(&, $n)} {
        @content;
    }
}


/// Outputs specificity in your CSS as (invalid) properties.
/// Please, don't use this mixin in production.
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access public
/// @output specificity (map as string), specificity-value (specificity value as integer)
@mixin specificity() {
    specificity: specificity(&);
    specificity-value: specificity(&, true);
}


/// Override current selector over given selector.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin override($args...) {
    @at-root #{override(&, $args...)} {
        @content;
    }
}


/// Filter given selector with given sub-selectors.
/// Every selector which does not contain any of given args will be excluded.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @throw SPOT CSS: only-for/in-register - the mixin default doesn't have to be registered in register mixin in component 'component'.
/// @throw SPOT CSS: only-for/default-is-missing - the only-for '$args' in component 'component' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).
/// @output Filtered selector(s) with given inner content.
@mixin only-for($args...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "only-for/in-register - the mixin only-for doesn't have to be registered in register mixin in component '"+component()+"'.";
    }
    // force using 'default' mixin when using modifiers
    @if not _default-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "only-for/default-is-missing - the only-for '"+inspect($args)+"' in component '"+component()+"' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).";
    }

    @at-root #{only-for(&, $args...)} {
        @content;
    }
}


@mixin already-defined-in($modifiers...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/in-register - the mixin already-defined-in doesn't have to be registered in register mixin in component '"+component()+"'.";
    }

    // do not allow outside of modifier(s)
    @if not $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/outside-modifiers - it is not allowed to use already-defined-in mixin outside of modifiers.";
    }
    // at least 2 nested modifiers
    $current-modifier-stack: map-get($_current-modifiers-stack, component()); // for this component
    @if length($current-modifier-stack) < 2 {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/at-least-2-modifiers - it is not allowed to use already-defined-in mixin only in single level modifier.";
    }
    // add 'already-defined-in' property into current modifier to the stack
    $current-modifier-stack: map-get($_current-modifiers-stack, component()); // for this component
    $modifier-pointer: map-get($_used-modifiers, component());
    $len: length($current-modifier-stack);
    $parents: []; 
    @each $modifier in $current-modifier-stack {
        $parents: append($parents, $modifier-pointer, 'comma');
        $modifier-pointer: map-get($modifier-pointer, $modifier);
    }
    $map: ('already-defined-in': $modifiers);
    @while length($parents)>0 {
        $i: length($parents);
        $name: nth($current-modifier-stack, $i);
        $last: nth($parents, $i);
        $map: map-merge($last, ($name: $map));
        $parents: nth-delete($parents, -1);
    }
    $_used-modifiers: map-merge($_used-modifiers, (component(): $map)) !global;
}


// Extends selector in the actual selector path
// ($something: '.item', $extenssion: '':first-child, :last-child') => $new-extension: 'item:first-child, item:last-child'
@mixin extend($something, $extension) {
    @at-root #{extend(&, $something, $extension)} {
        @content;
    }
}


/// Mandatory separator before each sub-element modifier. Use as long as you wish.
@mixin _ { @include _sub-element-separator; }
@mixin __ { @include _sub-element-separator; }
@mixin ___ { @include _sub-element-separator; }
@mixin ____ { @include _sub-element-separator; }
@mixin _____ { @include _sub-element-separator; }
@mixin ______ { @include _sub-element-separator; }
@mixin _______ { @include _sub-element-separator; }
@mixin ________ { @include _sub-element-separator; }
@mixin _________ { @include _sub-element-separator; }
@mixin __________ { @include _sub-element-separator; }
@mixin ___________ { @include _sub-element-separator; }
@mixin ____________ { @include _sub-element-separator; }
@mixin _____________ { @include _sub-element-separator; }
@mixin ______________ { @include _sub-element-separator; }
@mixin _______________ { @include _sub-element-separator; }
@mixin ________________ { @include _sub-element-separator; }
@mixin _________________ { @include _sub-element-separator; }
@mixin __________________ { @include _sub-element-separator; }
@mixin ___________________ { @include _sub-element-separator; }
@mixin ____________________ { @include _sub-element-separator; }
@mixin _____________________ { @include _sub-element-separator; }
@mixin ______________________ { @include _sub-element-separator; }
@mixin _______________________ { @include _sub-element-separator; }
@mixin ________________________ { @include _sub-element-separator; }
@mixin _________________________ { @include _sub-element-separator; }
@mixin __________________________ { @include _sub-element-separator; }
@mixin ___________________________ { @include _sub-element-separator; }
@mixin ____________________________ { @include _sub-element-separator; }
@mixin _____________________________ { @include _sub-element-separator; }
@mixin ______________________________ { @include _sub-element-separator; }
@mixin _______________________________ { @include _sub-element-separator; }
@mixin ________________________________ { @include _sub-element-separator; }
@mixin _________________________________ { @include _sub-element-separator; }
@mixin __________________________________ { @include _sub-element-separator; }
@mixin ___________________________________ { @include _sub-element-separator; }
@mixin ____________________________________ { @include _sub-element-separator; }
@mixin _____________________________________ { @include _sub-element-separator; }
@mixin ______________________________________ { @include _sub-element-separator; }
@mixin _______________________________________ { @include _sub-element-separator; }
@mixin ________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________________ { @include _sub-element-separator; }
@mixin _________________________________________________________ { @include _sub-element-separator; }
@mixin __________________________________________________________ { @include _sub-element-separator; }
@mixin ___________________________________________________________ { @include _sub-element-separator; }
@mixin ____________________________________________________________ { @include _sub-element-separator; }
@mixin _____________________________________________________________ { @include _sub-element-separator; }
@mixin ______________________________________________________________ { @include _sub-element-separator; }
@mixin _______________________________________________________________ { @include _sub-element-separator; }
@mixin ________________________________________________________________ { @include _sub-element-separator; }