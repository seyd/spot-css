/// Main top-level mixin to define component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another (with sub-component mixin).
///
/// @group Component
/// @access public
/// @param { String } $selector - single selector of component
/// @content
/// @throw SPOT CSS: component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: component/sub-component - you cannot use mixin component in component. Instead use mixin sub-component and also register it in parent component.
/// @throw SPOT CSS: component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: component/already-registered - given selector is already registered as component ({selector}).
/// @output Given selector with given content.
@mixin component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "component/no-selector - selector was expected but nothing passed.";
    }

    @if component()!='' {
        @error $SPOT_ERROR_PREFIX + "component/sub-component - you cannot use mixin component in component. Instead use mixin sub-component and also register it in parent component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $component-selector: $selector;

    // 1)
    // if already registred
    @if index($_registered-components, $component-selector)!=null {
        @error $SPOT_ERROR_PREFIX + "component/already-registered - given selector is already registered as component ('"+$component-selector+"').";
    }
    @else {
        // store component selector if is not stored yet
        $_registered-components: append($_registered-components, $component-selector, 'comma') !global;
    }

    // 2)
    // store current component selector (into stack)
    $_current-components: append($_current-components, $component-selector, 'space') !global;

    // // create map for used modifiers (nested) per component
    // $_used-modifiers: map-merge($_used-modifiers, (component(): ())) !global;
    // $_current-modifiers-stack: map-merge($_current-modifiers-stack, (component(): [])) !global;

    // @debug '-------------------------------';
    // @debug 'Component: '+component();

    #{$component-selector} {
        @content;
    }
    
    // @debug map-get($_used-modifiers, component());
    // @debug map-get($_current-modifiers-stack, component());

    // remove current component selector (from stack)
    $_current-components: pop($_current-components) !global;
}


/// Sub-component mixin to define component in component (with separate states, variants and sub-elements).
///
/// Context, responsive and browser modifiers are inherited from parent component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another.
///
/// @group Component
/// @access public
/// @param { String } $selector - single selector of sub-component
/// @content
/// @throw SPOT CSS: sub-component/no-selector - selector was expected but nothing passed.
/// @throw SPOT CSS: sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.
/// @throw SPOT CSS: sub-component/single-selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: sub-component/already-registered - trying to register already registered sub-component 'selector' for component 'component'.
/// @throw SPOT CSS: sub-component/childs-in-register - it is not allowed call any other modifiers and sub element mixins in sub-component in register of component 'component'. Register all those modifiers in register section of sub-component 'selector'.
/// @throw SPOT CSS: sub-component/unknown-unregistered - given sub-component 'selector' is not registered in direct parent component ('component').
/// @throw SPOT CSS: sub-component/duplicate - given selector is already used as sub-component ({selector}).
/// @output Given selector with given content.
@mixin sub-component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "sub-component/no-selector - selector was expected but nothing passed.";
    }

    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "sub-component/no-component - you cannot use mixin sub-component outside component. Sub-component can be used only in component.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "sub-component/single-selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $sub-component-selector: #{ & + ' > ' + $selector };


    @if $_is-register-mode { 
        // guarding duplicity of sub-components (and all sub selectors)
        @if index($_already-used-selectors, $sub-component-selector) or index($_registered-sub-components, $sub-component-selector) {
            @error $SPOT_ERROR_PREFIX + "sub-component/already-registered - trying to register already registered sub-component '"+$selector+"' for component '"+component()+"'.";
        }
        // store unique sub-component
        $_already-used-selectors: append($_already-used-selectors, $sub-component-selector, 'comma') !global;
        $_registered-sub-components: append($_registered-sub-components, $sub-component-selector, 'comma') !global;

        $_is-called-something-in-register: false !global;

        $_is-sub-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-sub-component-mode: false !global;

        // check if something was called inside sub-component (in register mode)
        @if $_is-called-something-in-register {
            @error $SPOT_ERROR_PREFIX + "sub-component/childs-in-register - it is not allowed call any other modifiers and sub element mixins in sub-component in register of component '"+component()+"'. Register all those modifiers in register section of sub-component '"+$selector+"'.";
        }
    }
    @else {
        // check if sub-component is registered
        @if not index($_already-used-selectors, $sub-component-selector) {
            @error $SPOT_ERROR_PREFIX + "sub-component/unknown-unregistered - given sub-component '"+$selector+"' is not registered in direct parent component ('"+$sub-component-selector+"').";
        }
        // 1)
        // if already registred
        @if index($_registered-components, $sub-component-selector)!=null {
            @error $SPOT_ERROR_PREFIX + "sub-component/duplicate - given selector is already used as sub-component ('"+$sub-component-selector+"').";
        }
        @else {
            // store component selector if is not stored yet
            $_registered-components: append($_registered-components, $sub-component-selector, 'comma') !global;
        }

        // 2)
        // store current component selector (into stack)
        $_current-components: append($_current-components, '> '+$selector, 'space') !global;

        $_is-sub-component-mode: true !global;

        @at-root
        #{$sub-component-selector} {
            @content;
        }

        $_is-sub-component-mode: false !global;

        // remove current component selector (from stack)
        $_current-components: pop($_current-components) !global;
    }
}


/// Main top-level mixin to define component.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: register/no-component - the mixin register must be used inside a component.
/// @throw SPOT CSS: register/already-called - the mixin register was already called for component 'component'.
/// @output Given selector with given content.
@mixin register {
    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "register/no-component - the mixin register must be used inside a component.";
    }
    
    /// @todo check if was called as first mixin in component
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // run only once per component
    @if _register-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "register/already-called - the mixin register was already called for component '"+component()+"'.";
    }
    @else {
        @include _set_register-mixin-was-already-called();
    }

    $_is-register-mode: true !global;
    @content;
    $_is-register-mode: false !global;
}


/// This mixins defines default component or sub elements style.
/// It is required only when other modifiers are used. 
/// This is not modifier so it has to be not registered in register mixin.
/// This mixin helps only in semantic matter better understanding of component style.
/// If just static style of an element, default mixin is not required.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: default/in-register - the mixin default doesn't have to be registered in register mixin in component 'component'.
/// @throw SPOT CSS: default/already-called - the mixin default was already called for element 'element'.
/// @output Just given content.
@mixin default {
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "default/in-register - the mixin default doesn't have to be registered in register mixin in component '"+component()+"'.";
    }    
    // run only once per component selector
    $current-media-selector: _wrap_into_media_selector(&);
    @if index($_default-called-on, $current-media-selector) {
        @error $SPOT_ERROR_PREFIX + "default/already-called - the mixin default was already called for element '"+$current-media-selector+"'.";
    }
    $_default-called-on: append($_default-called-on, $current-media-selector) !global;
    
    $_is-default-mode: true !global;
    @content;
    $_is-default-mode: false !global;
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register variant in current component.
///
/// 2) when used outside of register mixin, it will apply given variant(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require variant selector (and all values when placeholder '?' is used in variant selector) OR when not in regiter mode selector extension(s) = variant names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given variant(s) with given content.
@mixin variant($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('variant', $args...);
    }
    @else {
        @include _apply-modifier('variant', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>variant</b> but different semantic naming.
/// @see {mixin} variant
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin state($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('state', $args...);
    }
    @else {
        @include _apply-modifier('state', $args...) {        
            @content;
        }
    }   
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register context in current component.
///
/// 2) when used outside of register mixin, it will apply given context(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require context selector and optional alias OR when not in regiter mode selector extension(s) = context names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given context(s) with given content.
@mixin context($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('context &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('context &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>context</b> but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin browser($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('browser &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('browser &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>context</b> but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin responsive($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('responsive &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('responsive &', $args...) {        
            @content;
        }
    }   
}


/// Declares direct child block in current component selector.
/// @group Component
/// @access public
/// @param { String } $args... - One or more selectors of direct childs. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: child-element/no-selectors - at least one child selector is expected.
/// @throw SPOT CSS: child-element/in-modifier - it is not allowed to use child-element in modifier 'modifier'.
/// @throw SPOT CSS: child-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: child-element/multilevel-selector - given selector is not a single selector ('selector'). Just use more child-element mixins nested.
/// @output Given selector with given content.
@mixin child-element($args...) {
    @if length($args)==0 {
        @error $SPOT_ERROR_PREFIX + "child-element/no-selectors - at least one child selector is expected.";
    }
    // do not allow in modifier
    @if $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "child-element/in-modifier - it is not allowed to use child-element in modifier '"+$_current_modifier+"'.";
    }

    @if $_is-register-mode {
        // mark flag that some modifier was called in register mixin
        $_is-called-something-in-register: true !global;
    }
    @else {
        // store appling sub element in current selector to avoid calling state, variant, etc. after that
        @if not index($_selectors-with-sub-elements, &) {
            $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
        }
    }

    $selectors: (); 
    @each $selector in $args {
        $parts: selector-parse($selector);
        // @feature Forcing using only single selector in one selector string. It could be passed more selectors in separate arguments.
        @if length($parts)>1 {
            @error $SPOT_ERROR_PREFIX + "child-element/single-selector - given selector is not a single selector ('"+$selector+"'). Just pass it as a separate argument.";
        }        
        // all child selectors must start with >
        @if str-index(str-trim-left($selector), '>')!=1 and str-last-char(#{&})!='>' {
            $selector: '> '+$selector;
        }
        // @feature Guarding that only first (one) level child selector is passed.
        // Value 2 because also starting '>' is counted
        @if length-of-simple-selector($selector)>2 {
            @error $SPOT_ERROR_PREFIX + "child-element/multilevel-selector - given selector is not a single selector ('"+$selector+"'). Just use more child-element mixins nested.";
        }   
        $selectors: append($selectors, $selector, 'comma');
    }
    #{$selectors} {
        @content;
    }
}


/// Declares any other then child block in current component selector. 
/// It is same as child-element mixin, but it does not force direct child selector (>) and
/// it could contain multilevel selectors also (e.g. 'div a.disabled span').
/// Note: It is strongly recomended to use <b>child-element</b> mixin everytime it is possible!
/// @group Component
/// @access public
/// @param { String } $args... - One or more selectors. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: sub-element/no-selectors - at least one selector is expected.
/// @throw SPOT CSS: sub-element/in-modifier - it is not allowed to use sub-element in modifier 'modifier'.
/// @throw SPOT CSS: sub-element/single-selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @output Given selector with given content.
@mixin sub-element($args...) {
    @if length($args)==0 {
        @error $SPOT_ERROR_PREFIX + "sub-element/no-selectors - at least one selector is expected.";
    }
    @if $_is-register-mode {
        // mark flag that some modifier was called in register mixin
        $_is-called-something-in-register: true !global;
    }
    // do not allow in modifier
    @if $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "sub-element/in-modifier - it is not allowed to use sub-element in modifier '"+$_current_modifier+"'.";
    }
    // store appling sub element in current selector to avoid calling state, variant, etc. after that
    @if not index($_selectors-with-sub-elements, &) {
        $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
    }
    $selectors: (); 
    @each $selector in $args {
        $parts: selector-parse($selector);
        // @feature Forcing using only single selector in one selector string. It could be passed more selectors in separate arguments.
        @if length($parts)>1 {
            @error $SPOT_ERROR_PREFIX + "sub-element/single-selector - given selector is not a single selector ('"+$selector+"'). Just pass it as a separate argument.";
        }        
        $selectors: append($selectors, $selector, 'comma');
    }
    #{$selectors} {
        @content;
    }
}


/// Declares pseudo element(s) of current component selector.
/// @group Component
/// @access public
/// @param { String } $first - pseudo selector 'before' or 'after' (also prefixes ':' and ':: are accepted)
/// @param { String } $second - pseudo selector 'before' or 'after' (also prefixes ':' and ':: are accepted)
/// @content
/// @throw SPOT CSS: pseudo-element/no-selectors - at least one pseudo selector is expected ('before' or 'after').
/// @throw SPOT CSS: pseudo-element/in-modifier - it is not allowed to use pseudo-element in modifier 'modifier'.
/// @throw SPOT CSS: pseudo-element/invalid-selector - Invalid value for pseudo element 'selector'. Only valid values are 'before', 'after', 'first-letter', 'first-line', 'placeholder' or 'selection'.
/// @throw SPOT CSS: pseudo-element/already-used - the pseudo-element('pseudo-selector') is already used somewhere higher! Do not break the SPOT rule and use just single place for every pseudo-element.
/// @output Given selector with given content.
@mixin pseudo-element($selectors...) {
    @if length($selectors)==0 or not first($selectors) or first($selectors)=='' {
        @error $SPOT_ERROR_PREFIX + "pseudo-element/no-selectors - at least one pseudo selector is expected ('before' or 'after').";
    }
    @if $_is-register-mode {
        // mark flag that some modifier was called in register mixin
        $_is-called-something-in-register: true !global;
    }
    // do not allow in modifier
    @if $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "pseudo-element/in-modifier - it is not allowed to use pseudo-element in modifier '"+$_current_modifier+"'.";
    }
    // store appling sub element in current selector to avoid calling state, variant, etc. after that
    @if not index($_selectors-with-sub-elements, &) {
        $_selectors-with-sub-elements: append($_selectors-with-sub-elements, &) !global;
    }

    $output: ();
    @each $pseudo-selector in $selectors {   
        // replace all colons (':' and '::')
        $pseudo-selector: str-trim(str-replace(str-replace($pseudo-selector, '::', ''), ':', ''));

        @if $pseudo-selector!='before' and $pseudo-selector!='after' and $pseudo-selector!='first-letter' and $pseudo-selector!='first-line' and $pseudo-selector!='placeholder' and $pseudo-selector!='selection' {
            @error $SPOT_ERROR_PREFIX + "pseudo-element/invalid-selector - Invalid value for pseudo element '"+$pseudo-selector+"'. Only valid values are 'before', 'after', 'first-letter', 'first-line', 'placeholder' or 'selection'.";
        }

        $selector: & + '::' + $pseudo-selector;

        @if index($_already-used-selectors, $selector) {
            @error $SPOT_ERROR_PREFIX + "pseudo-element/already-used - the pseudo-element('" + $pseudo-selector + "') is already used somewhere higher! Do not break the SPOT rule and use just single place for every pseudo-element.";
        }
        $_already-used-selectors: append($_already-used-selectors, $selector) !global;

        $output: append($output, $selector, 'comma');
    }
    
    @at-root
    #{$output} {
        @content;
    }
}


/// Add selector specificity at element level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-element-specificity($n) {
    @at-root #{add-element-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at class level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-class-specificity($n) {
    @at-root #{add-class-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at id level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-id-specificity($n) {
    @at-root #{add-id-specificity(&, $n)} {
        @content;
    }
}


/// Outputs specificity in your CSS as (invalid) properties.
/// Please, don't use this mixin in production.
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access public
/// @output specificity (map as string), specificity-value (specificity value as integer)
@mixin specificity() {
    specificity: specificity(&);
    specificity-value: specificity(&, true);
}


/// Override current selector over given selector.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin override($args...) {
    @at-root #{override(&, $args...)} {
        @content;
    }
}


/// Filter given selector with given sub-selectors.
/// Every selector which does not contain any of given args will be excluded.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @throw SPOT CSS: only-for/in-register - the mixin default doesn't have to be registered in register mixin in component 'component'.
/// @throw SPOT CSS: only-for/default-is-missing - the only-for '$args' in component 'component' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).
/// @output Filtered selector(s) with given inner content.
@mixin only-for($args...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "only-for/in-register - the mixin only-for doesn't have to be registered in register mixin in component '"+component()+"'.";
    }
    // force using 'default' mixin when using modifiers
    @if not _default-mixin-was-already-called() {
        @error $SPOT_ERROR_PREFIX + "only-for/default-is-missing - the only-for '"+inspect($args)+"' in component '"+component()+"' was used but default mixin wasn't used before it. Add 'default' mixin before all modifiers at first (even if it stays empty).";
    }

    @at-root #{only-for(&, $args...)} {
        @content;
    }
}


@mixin already-defined-in($modifiers...) {
    // not allowed in register
    @if $_is-register-mode {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/in-register - the mixin already-defined-in doesn't have to be registered in register mixin in component '"+component()+"'.";
    }

    // do not allow outside of modifier(s)
    @if not $_is-modifier-mode {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/outside-modifiers - it is not allowed to use already-defined-in mixin outside of modifiers.";
    }
    // at least 2 nested modifiers
    $current-modifier-stack: map-get($_current-modifiers-stack, component()); // for this component
    @if length($current-modifier-stack) < 2 {
        @error $SPOT_ERROR_PREFIX + "already-defined-in/at-least-2-modifiers - it is not allowed to use already-defined-in mixin only in single level modifier.";
    }
    // add 'already-defined-in' property into current modifier to the stack
    $current-modifier-stack: map-get($_current-modifiers-stack, component()); // for this component
    $modifier-pointer: map-get($_used-modifiers, component());
    $len: length($current-modifier-stack);
    $parents: []; 
    @each $modifier in $current-modifier-stack {
        $parents: append($parents, $modifier-pointer, 'comma');
        $modifier-pointer: map-get($modifier-pointer, $modifier);
    }
    $map: ('already-defined-in': $modifiers);
    @while length($parents)>0 {
        $i: length($parents);
        $name: nth($current-modifier-stack, $i);
        $last: nth($parents, $i);
        $map: map-merge($last, ($name: $map));
        $parents: nth-delete($parents, -1);
    }
    $_used-modifiers: map-merge($_used-modifiers, (component(): $map)) !global;
}


// Extends selector in the actual selector path
// ($something: '.item', $extenssion: '':first-child, :last-child') => $new-extension: 'item:first-child, item:last-child'
@mixin extend($something, $extension) {
    @at-root #{extend(&, $something, $extension)} {
        @content;
    }
}