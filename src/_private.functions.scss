/// Create unique string for combination $component + $identifier.
/// @group Component
/// @access private
/// @return { String } Unique string identifier.
@function _get-component-identifier($component, $identifier) {
    @return $component+'---'+$identifier;
}


/// Create unique string for combination $component + $modifier.
/// @group Component
/// @access private
/// @return { String } Unique string modifier.
@function _get-component-modifier($component, $modifier) {
    @return $component+'___'+$modifier;
}

/// Return map of registered mutations on component.
/// @group Component
/// @access private
/// @return { Map } Map uf mutations (key is mutation selector and value mutation props, e.g. alias).
@function _get-component-modifiers($component, $modifier) {
    @return map-get($_registered-modifiers, $component+'___'+$modifier);
}


/// @todo tests
/// @access private
@function _add-default-ampersand-if-context($modifier-name, $identifier) {
    @if str-index($modifier-name, '&') and not str-index($identifier, '&') {
        // when selector does not define '&' implicitly, it add it on the end of selector by default
        @return $identifier + ' &';
    }
    @else {
        @return $identifier;
    }
}


/// Returns pseudo element from selector if it's present.
/// @access public
/// @param { String } $selector - single selector
/// @return { String | null } Pseudo element or null if not found.
@function _get-pseudo-element($selector) {
    $last-selector: nth($selector, length($selector));
    $len: length($_standard-pseudo-elements);
    @for $i from 1 through $len - 1 {
        // check single : for bullet proof reason
        $index: str-index($last-selector, ':'+nth($_standard-pseudo-elements, $i));
        @if $index!=null {
            // check double ::
            @if str-index($last-selector, '::'+nth($_standard-pseudo-elements, $i)) {
                $index: $index - 1;
            }
            @return str-slice($last-selector, $index, -1);
        }   
    }
    // non-standard pseudo elements, e.g. ::-webkit-
    $index: str-index($last-selector, '::-');
    @if $index!=null {
        @return str-slice($last-selector, $index, -1);
    }
    @return null;
}

// add selector specificity at `given` level
@function _add-selector-specificity($selector, $n, $not-what-mark) {
    $selectors: selector-parse($selector);
    $output: ();
    $addon: '';
    @for $i from 1 to $n+1 {
        $addon: $addon + ':not(' + $not-what-mark + ')';
    }
    // for each selector (if more selectors in $selector)
    @each $single-selector in $selectors {
        $single-selector: to-string($single-selector);
        $pseudo-element: _get-pseudo-element($single-selector);
        @if $pseudo-element!=null {
            $single-selector: str-replace($single-selector, $pseudo-element, '');
            $single-selector: $single-selector + $addon + $pseudo-element;
        }
        @else {
            $single-selector: $single-selector + $addon;
        }
        $output: append($output, $single-selector, 'comma');
    }
    @return #{$output};
}


// see test /private/functions/get-all-combinations.sass
// recursive
@function _get-all-combination($args...) {
    $len: length($args);
    @if $len==0 {
        @return []; 
    }
    $combinations: [];
    @for $i from 1 through $len {
        $comb: [];
        $comb: append($comb, nth($args, $i), 'comma');
        $rest: _get-all-combination( nth-delete($args, $i)... );
        @each $rest-comb in $rest {
            $combinations: append($combinations, join($comb, $rest-comb), 'comma');
        }
        @if length($rest)==0 {
            $combinations: append($combinations, $comb, 'comma');
        }
    }

    @return $combinations;
}

 
/// SCSS Specificity Calculator
///
/// Replaces a batch of substrings (needles) in a string (haystack)
/// with a single replacement string.
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access private
/// @param {String} $haystack - string to perform search and replacement on
/// @param {List | String} $needles - string or list of strings to replace globally
/// @param {String} $replacement ('') - replacement string to replace needles
/// @return {String} replaced string
@function _str-replace-batch($haystack, $needles, $replacement: '') {
    $instances: false;
    
    @if not type_of($needles) == list { $needles: ($needles); }
    
    @while ($instances == false) or ($instances > 0) {
        $instances: 0;
        
        @each $needle in $needles {
            $needle-index: str-index($haystack, $needle);
            $instances: $instances + if($needle-index, 1, 0);
            
            @if $needle-index {
                $haystack: str-slice($haystack, 1, $needle-index - 1) + str-slice($haystack, $needle-index + str-length($needle), -1);
                $haystack: str-insert($haystack, $replacement, $needle-index);
            }
        }
    }
    
    @return $haystack;
}
 

/// Signifies what specificity type the simple selector is.
/// a - IDs
/// b - class selectors, attribute selectors, pseudo-classes
/// c - type (element) selectors, pseudo-elements
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access private
/// @param {String} $simple-selector - a single simple selector
/// @return {String} specificity type of simple selector - 'a', 'b', 'c', or false
@function _specificity-type($simple-selector) {
    $types: (
        c: (':before', ':after', ':backdrop', ':cue', ':cue-region', ':first-letter', ':first-line', ':file-selector-button', ':grammar-error', ':marker', ':part(', ':placeholder', ':selection', ':slotted(', ':spelling-error(', ':target-text', '::-'),
        b: ('.', '[', ':'),
        a: ('#')
    );
    
    $simple-selector: _str-replace-batch($simple-selector, '::-', ':-custom-pseudo-element-');
    $simple-selector: _str-replace-batch($simple-selector, '::', ':');
    $simple-selector: _str-replace-batch($simple-selector, ':-custom-pseudo-element-', '::-');
    
    @if str-index($simple-selector, ':not(') == 1 {
        $simple-selector: str-slice($simple-selector, 6, -2);
    }
    
    @each $type-key, $type-tokens in $types {
        @each $token in $type-tokens {
            @if str-index($simple-selector, $token) == 1 {
                @return $type-key;
            }
        }
    }
    
    // Ignore the universal selector
    @if str-index($simple-selector, '*') == 1 {
        @return false;
    }
    
    // Simple selector is type selector (element)
    @return c;
}

 
/// Returns the specificity value (in the specified base).
/// Base is set to 256 (16^2) to accurately represent historical 6-digit
/// hexadecimal representation of specificity in most browsers, though this
/// limitation has been "resolved" in some browsers (try base 65536 for those).
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access private
/// @param {Map} $specificity-map - map of frequency of each type (a, b, c) in complex selector
/// @param {Number} $base (256) - base used to calculate specificity value (default: 256)
/// @return {Number} specificity value of given specificity map as base 10 integer
@function _specificity-value($specificity-map, $base: 256) {
    $exponent-map: (a: 2, b: 1, c: 0);
    $specificity: 0;
    
    @each $specificity-type, $specificity-value in $specificity-map {
        $specificity: $specificity + ($specificity-value * pow($base, map-get($exponent-map, $specificity-type)));
    }
    
    @return $specificity;
}


/// Checks if mixin register was already called in component.
/// @access private
/// @return {Boolean} True if mixin register was already called in current component.
@function _register-mixin-was-already-called() {
    @return index($_register-called-on, component()) != null;
}


/// Checks if mixin default was already called in current selector.
/// @access private
/// @return {Boolean} True if mixin register was already called in current selector.
@function _default-mixin-was-already-called() {
    $current-media-selector: _wrap-into-media-selector(&);
    @return index($_default-called-on, $current-media-selector) != null;
}


/// Wraps given selector into current media query stack to return unique selector
/// to avoid duplicite usage of modifiers.
@function _wrap-into-media-selector($selector) {
    $current-media-selector: '';
    $is_media: length($_current-media-stack)>0;
    @if $is_media {
        $current-media-selector: '@media ' + inspect($_current-media-stack) + ' { ';
    }    
    $current-media-selector: $current-media-selector + $selector;
    @if $is_media {
        $current-media-selector:  $current-media-selector + inspect($_current-media-stack) + ' }';
    }    
    @return $current-media-selector;
}


/// Check if given modifier name is context-like modifier.
/// @access private
/// @param {String} $modifier-name - name of modifier
/// @return {Boolean} True if given modifier name is context-like modifier.
@function _is-modifier-context-like($modifier-name) {
    @return str-index($modifier-name, ' &') != null; // 'context &' | 'responsive &' | 'browser &' 
}


@function _prepend-selector-context($selector, $context) {
    $html-element-part: [];
    $body-element-part: [];
    $rest-selector-part: [];
    // split selector into 3 parts (html, body and rest)
    @each $partial-selector in $selector {
        $first-part: "";
        @if not _is-selector-combinator($partial-selector) {
            $first-part: to-lower-case(nth(simple-selectors($partial-selector), 1));
        }
        
        @if $first-part == 'html' {
            $html-element-part: append($html-element-part, $partial-selector, 'space');
        }
        @else if $first-part == 'body' {
            $body-element-part: append($body-element-part, $partial-selector, 'space');
        }
        @else {
            $rest-selector-part: append($rest-selector-part, $partial-selector, 'space');
        }
    }
    // add context
    @each $partial-selector in $context {
        $first-part: "";
        @if not _is-selector-combinator($partial-selector) {
            $first-part: to-lower-case(nth(simple-selectors($partial-selector), 1));
        }

        @if $first-part == 'html' {
            $html-element-part: append($html-element-part, $partial-selector, 'space');
        }
        @else if $first-part == 'body' {
            $body-element-part: append($body-element-part, $partial-selector, 'space');
        }
        @else {
            $rest-selector-part: append($rest-selector-part, $partial-selector, 'space');
        }
    }
    // join parts
    $selector: join(join($html-element-part, $body-element-part, $bracketed: false), $rest-selector-part, $bracketed: false);
    @return #{ $selector };
}


/// Check if given simple selector is combinator ('>', '+', '~').
/// @access private
/// @param {String} $simple-selector - simple selector
/// @return {Boolean} True if iven simple selector is combinator.
@function _is-selector-combinator($simple-selector) {
    @return $simple-selector==">" or $simple-selector=="+" or $simple-selector=="~";
}

/// Remove combinator selector ('>', '+', '~') from given simple selector.
/// @access private
/// @param {String} $simple-selector - simple selector
/// @return {String} Given selector without combinator selector.
/// @see @function selector-trim-combinators($selector)
@function _remove-combinator-selector($simple-selector) {
    @return str-trim(str-replace(str-replace(str-replace(str-replace($simple-selector+'', '>', ''), '+', ''), '~', ''), '  ', ' '));
}


/// Returns if given string starts with char "{" and ends with "}", that means it's alias.
@function _is-alias($str) {
    @return str-index($str, '{')==1 and str-index($str, '}')==str-length($str);
}


/// Removes spaces from alias, e.g. "{ Text }" => "{Text}"
@function _normalize-alias($alias) {
    @return str-replace(str-replace($alias, '{ ', '{'), ' }', '}');
}

/// There was problem with extend() function on "combinator selectors" (e.g. "section > div"), so this is the solution => substitution.
@function _extend_component_selector($selector, $subselector-to-extend, $extension) {
    $selectors: selector-parse($selector);
    $output: ();
    
    $is-subselector-extension: is-element-selector($subselector-to-extend);
    $is-element-extension: is-element-selector($extension);
    
    @each $single-selector in $selectors {
        $is-combinator-selector: combinator-selector-length($single-selector)>1;
        // if special case (extension is an element selector, e.g. "i", so ".btn > .icon" is extended with "i" => ".btn > i.icon")
        @if $is-element-extension and $is-combinator-selector {
            $extended-selector: _extend-last-element-in-selector-with-element-selector($subselector-to-extend, $extension);
            $output: append($output, str-replace($single-selector+'', $subselector-to-extend, $extended-selector), 'comma');
        }
        @else {
            $substitution: '';

            @if $is-subselector-extension==false and is-part-of-element-subselector($single-selector, $subselector-to-extend) {
                $substitution: ':is(___SUBSELECTOR_TO_EXTEND___)';
            }
            @else {
                $substitution: '___SUBSELECTOR_TO_EXTEND___';
            }

            $current-selector: str-replace($single-selector+'', $subselector-to-extend, $substitution);
            $extended-selector: extend($current-selector, $substitution, $extension);
            $output: append($output, str-replace($extended-selector+'', $substitution, $subselector-to-extend), 'comma');
        }
    }
    @return #{$output};
}

@function _error($code) {
    @return 'SPOT CSS ['+$code+']';
}

@function _warn($code, $text) {
    @warn 'SPOT CSS ['+$code+'] - ' + $text;
    @return 'SPOT CSS ['+$code+']'; // for unit tests
}

// when $single-selector is a combinator selector, e.g. "header > .btn"
// when $extension is an element selector, e.g. "button"
// expected output is "header > button.btn"
@function _extend-last-element-in-selector-with-element-selector($single-selector, $extension) {
    $parts: nth(selector-parse($single-selector), 1);
    $last: nth($parts, length($parts));
    $extended: $extension+$last+'';
    @return str-replace($single-selector+'', $last+'', $extended);
}

// Removes "state(...)" or "variant(...)" or "context(...)" wrapper.
// E.g.  "state(.something)" => ".something"
@function _remove-mutation-wrapper($simple-selector) {
    // trim first 8 chars, e.g. 'state("'
    $start8: str-slice($simple-selector, 1, 8);
    @if $start8=='state("' {
        @return str-slice($simple-selector, 9, -3);
    }

    // trim first 9 chars, e.g. 'variant("' or 'context("'
    $start9: str-slice($simple-selector, 1, 9);
    @if $start8=='variant(' or $start8=='context(' {
        @return str-slice($simple-selector, 10, -3);
    }

    @return $simple-selector;
}